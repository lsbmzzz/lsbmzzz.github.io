---
layout:     post
title:      Java并发编程实战
subtitle:   Java并发编程实战
date:       2019-10-03
author:     正版慕言
header-img: img/blog_bg_1.jpg
catalog: true
mathjax: true
tags:
    - Java并发编程实战

---

# 线程带来的风险

1. 安全性问题：没有充足同步的情况下，多个线程的执行顺序不可预测
2. 活跃性问题：“某件正确的事最终会发生”，死锁、饥饿、活锁等
3. 性能问题：多线程切换时的上下文切换操作需要很大的开销。

# 线程安全性

如果多个线程访问同一个可变状态变量时没有合适的同步，就会出现错误。解决的方法：
- 不要共享该状态变量
- 将该状态变量修改为final
- 使用同步

线程安全类：多个线程访问一个类时，不管运行时环境采用何种调度方式或这些线程如何交替执行，且不需要在主调代码中采用任何同步，这个类都能表现出正确行为，那么这个类就是线程安全的。

竞态条件：由于不恰当的执行顺序而出现不正确的结果。

最常见的竞态条件类型是“先检查后执行”：通过一个可能失效的观测结果来决定下一步动作。

#### 加锁机制

内置锁：Java提供了一种内置的锁机制来支持原子性：同步代码块。
- 同步代码块包括两部分：一部分作为锁对象的引用，另一部分是由这个锁保护的代码块。
- synchronized修饰的方法是一种整个方法体的同步代码块，它的锁就是方法调用所在的对象。如果是静态的方法，则是以class对象作为锁。
- 每个Java对象都可以用作一个实现同步的锁，称为内置锁或监视器锁。线程进入同步代码块时自动获得锁，退出时自动释放锁。

重入：如果一个线程要获取一个已经由他自己持有的锁，请求就会成功。
- 为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁被认为没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数值减1。

#### 活跃性与性能

1. 不要将同步代码块分解的过细，因为获取和释放锁需要开销。
2. 执行时间较长的计算或者可能无法快速完成的操作时，不要持有锁。
3. 不要同时使用两种不同的同步机制，会带来混乱。

# 对象的共享

#### 可见性

内存可见性：当一个线程修改了对象状态后，其他线程能够看到发生的变化。

通过加锁不仅可以实现互斥，还包括内存可见性。

重排序：在没有同步的情况下，编译器、处理器和运行时等都可能对操作的执行顺序进行一些调整。

失效数据：在没有同步的情况下，线程去读取变量时，可能读到一个已经失效的值。更糟糕的是失效值可能不同时出现：一个线程可能获得一个变量的最新值，而获得另一个变量的失效值。

最低安全性：在没有同步的情况下，可能会得到一个失效值，但至少这个值不是一个随机值。

例外：非volatile的64位操作数变量(long和double)

volatile变量：稍弱一点的同步机制，用于将变量的更新操作通知到其他线程。volatile变量不会被与其他操作一起重排序，也不会被缓存，因此能够确保可见性。但不能保证原子性。

#### 发布与逸出

发布：对象能够在当前作用域之外的代码中使用。

- 发布一个对象最简单的方法是将对象的引用保存到一个共有的静态变量，让任何类和线程都能看到。
- 发布一个对象时，在该对象的非私有域中引用的所有对象都会被发布。
- 发布一个内部的类实例，内部类实例关联一个外部类引用。

逸出：某个不该被发布的对象被发布。

#### 线程封闭

不共享数据，仅在单线程内访问数据，就不需要同步。这种技术称为线程封闭。

线程封闭技术：
- Ad-hoc线程封闭：维护线程封闭的任务完全由程序实现来完成
- 栈封闭：是线程封闭的一种特例，只能通过局部变量才能访问对象。
- ThreadLocal类：是一种更规范的方法，这个类能让线程中的某个值与保存值的对象关联起来。
    + 它提供了get()和set()方法，为每个使用该变量的线程都保存了一份独立的副本，因此get()总是返回由当前执行线程调用set()时设置的新值。

#### 不变性

不可变对象是另一种满足同步需求的方法。不可变对象一定是线程安全的。

不可变对象：
- 对象创建后其状态就不可被修改
- 对象的所有域都是final类型
- 对象是正确创建的(创建期内this没有引用逸出)

#### 安全发布

一些情况下我们希望在多个线程之间共享对象，就必须确保安全的共享。

可变对象必须以安全的方式来发布，这意味着发布和使用该对象的线程必须使用同步。

- 安全发布对象，对象的引用和对象的状态必须同时对其他线程可见。可以通过以下方式来安全发布一个正确构造的对象：
    + 在静态初始化函数中初始化一个对象的引用
    + 将对象的引用保存到volatile类型的域或者AtomicReferance对象中
    + 将对象的引用保存到某个正确构造对象的final类型域中
    + 将对象的引用保存到一个由锁保护的域中

- 安全共享对象，可以使用一些策略：
    + 线程封闭，将对象封闭在一个线程中
    + 只读共享
    + 线程安全共享，在对象的内部实现了同步
    + 保护对象，被保护的对象只能通过持有锁来访问

# 对象的组合

设计线程安全的类要包含三个基本要素

- 找出构成对象状态的所有变量
- 找出约束状态变量的不变性条件
- 建立对象状态的并发访问管理策略

如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量操作上也不存在任何不允许的状态转化，那么就可以安全的发布这个变量。

# 基础构建模块

在并发环境中使用容器的迭代器需要留意ConcurrentModificationException错误。在非Concurrent的容器中，比如只是单纯同步的Vector容器，其提供的迭代器如果在访问数据期间发现容器结构变化（内部应该有修改计数器之类的保存容器状态），会提醒ConcurrentModificationException错误

ConcurrentHashMap替代同步Map。使用粒度更细的分段锁机制提供更高的并发粒度。迭代器不会抛出ConcurrentModificationException。

CopyOnWriteArrayList代替同步的List。只要正确发布一个事实不可变的对象，在访问该对象时就不需要进一步的同步。每次修改时，都会创建并病重新发布一个新的容器副本从而实现可变性。
- 复制会需要一定的开销。仅当迭代操作远多于修改操作时，才赢噶使用“写入时复制”容器。

#### 同步工具类

- 闭锁：作用相当于一扇门：在闭锁到达结束前，门一直是关闭的，没有任何线程能通过。到达结束状态时，门会打开并允许所有线程通过。闭锁结束后，门将永远是打开状态。
- FutureTask：通过Callable实现，可以处于等待运行、正在运行和运行完成三种状态。Future.get的行为取决于任务状态。如果已完成，可以立即返回结果；否则，get阻塞直到任务进入完成状态。
- 信号量：控制同时访问特定资源的操作数量。用await方法获得资源，release方法释放资源。
- 栅栏：用来阻塞一组线程，直到某个事件发生。闭锁是用来等待事件，而栅栏是用来等待其他线程。


