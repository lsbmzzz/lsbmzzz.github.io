---
layout:     post
title:      MySQL与innoDB相关
subtitle:   MySQL与innoDB相关
date:       2019-09-03
author:     正版慕言
header-img: img/blog_bg_1.jpg
catalog: true
mathjax: true
tags:
    - MySQL

---

# 数据库范式

1. 第一范式(1NF)无重复的列：数据库中每一列都是不可分割的基本数据项。某种属性有多个值时，必须拆分为不同属性。不满足1NF的数据库不是关系数据库。
2. 第二范式(2NF)在1NF的基础上，属性完全依赖于主键：要求记录有唯一标识，通俗的说要有主键ID。
3. 第三范式(3NF)在2NF的基础上，消除传递依赖：是对字段冗余性的约束，任何字段不能由其它字段派生出来。
4. BCNF：在3NF的基础上，主属性不依赖于主属性。

# MySQL事务

MySQL事务可以理解为一系列的操作。一个事务要么成功执行，要么失败。

事务的特性：

1. 原子性：事务开始后的所有操作，要么全部完成，要么全部不做。事务执行过程中如果出错，会回滚到开始前的状态。
2. 一致性：事务开始前和结束后，数据库的完整性约束没有被破坏。比如A转账给B，不可能A转出了，B却没收到。
3. 隔离性：同一时间只允许一个事务请求同一数据，不同的事务之间彼此没有干扰。
4. 持久性：事务完成后，事务对数据库的所有更新将被保存到数据库且不能回滚。

# 约束

数据的完整性指数据的正确性和一致性。

#### 数据完整性有三种形式

1. 实体完整性保证表中有一个主键(primary key或unique key,或触发器)
2. 域完整性保证数据每列的值满足一定的条件(选择合适的数据类型、外键、触发器等)
3. 参照完整性保证两表之间的关系(外键、触发器)

#### innoDB提供的约束

1. primary key
2. unique key
3. foreign key
4. default 插入默认值
5. not null 非空

约束与索引的区别：约束是一个逻辑的概念，用来保证数据完整性；索引是一种物理结构。

#### enum和set约束

指定字段只能取一系列给定的值。
enum的值必须是指定的字符类型的值，且只能取给定的值之一。
set是一个字符串对象，必须是空字符串或以逗号分隔的值，一个set最多指定64个不同的值。

#### 触发器trigger

事先为一张表绑定一段代码，当表中一些内容发生改变(insert, delete, update)，系统自动触发这些代码并执行。

触发器的三要素：

1. 事件类型：insert, delete, update
2. 触发时间：before, after
3. 触发对象：整张表

每张表只能拥有一种触发时间的一种事件类型的触发器，因此最多拥有6个触发器。

[mysql触发器](https://blog.csdn.net/qq_35246620/article/details/78946070)

# 视图

视图是一种虚拟的表，是作为一个select保存在数据字典中的。
视图的功能和物理的表相同。对视图的修改不影响基本表，起一个“安全层”的作用。

# 数据库存储引擎

## innoDB

#### innoDB的特性

1. 插入缓冲(insert buffer)
	对于非聚集索引来说，叶子节点的插入是无序的，因此就需要离散的访问非聚集索引页，降低了插入性能。
	对非聚集类索引的插入和更新操作，不是每次直接插入索引页，而是先插入到内存中。具体做法：如果该索引页在缓冲池中，直接插入；如果不在，现将其放在缓冲区中，再以一定频率和索引页合并，这时候就可以将同一个索引页中的多个插入合并到一个IO操作中，从而提高写性能。
	插入缓冲的启用需要满足下面的条件：
	- 索引是辅助索引
	- 索引不是唯一的。如果是唯一的，那么在插入时就需要查找辅助索引进行判断来确保唯一性，因此就没有意义了。
	产生的问题：
	- 导致数据库宕机后的恢复时间更长。一旦出现宕机，内存中会有大量数据没有合并到索引页中，从而导致实例的回复时间较长。
	- 插入缓冲在写密集的情况下会占用较多的缓冲池内存。
2. 二次写(doublewrite)
	在数据库正在从内存向磁盘写入一个数据页时，如果发生宕机，会导致该页只写了部分数据（部分写失效），导致数据丢失。这无法通过重做日志恢复。
	两次写的原理：
	- 当刷新缓冲池脏页时，并不直接写入数据文件中，而是先拷贝到内存中的两次写缓冲区(doublewrite buffer, 2MB)
	- 通过doublewritebuffer分两次，每次1MB顺序的写入磁盘共享表空间。
	- 将doublewrite buffer写入数据文件。
	这样由于磁盘共享表空间中已经有了数据页的副本，因此在实例恢复时可以从共享表空间中找到副本，将其拷贝覆盖原有的数据也，然后应用重做日志即可。第二部是额外的开销，但由于磁盘共享表空间是连续的，因此开销并不大。
3. 自适应哈希索引
	哈希索引查找的时间复杂度为常量，而B+树高度一般为3-4层。当innoDB观察到建立哈希索引可以带来速度提升时，则建立哈希索引。因此称为自适应哈希索引(Adaptive Hash Index, AHI)。AHI通过缓冲池的B+树页构造，不需要对整个表建立哈希索引，因此速度很快。

## innoDB和myISAM的区别

1. innoDB支持事务，myISAM不支持
2. innoDB锁粒度是行级，myISAM锁粒度是表级
3. innoDB支持数据库并发控制MVCC，myISAM不支持
4. innoDB支持外键，myISAM不支持
5. innoDB不支持全文索引，myISAM支持全文索引

myISAM管理非事务表，它能够提供高速存储和检索，并具有全文搜索能力。如果有大量的select查询，myISAM性能较好。

innoDB用于事务处理应用程序。如果有大量的insert和update操作，应该使用innoDB。

# delete drop truncate的区别

delete和truncate只删除数据，不删除表结构， drop删除表结构
速度上 drop > truncate > delete

不再需要表时drop
清空表用truncate
删除部分记录用delete

# 索引

#### 索引组织表

在innoDB存储引擎中，表都是根据主键顺序组织存放的，这种存储方式称为索引组织表。
在innoDB存储引擎表中，每张表都有一个主键，如果没有显示定义主键，innoDB会按照下面的方法选择或创建主键：

- 判断表中有没有非空唯一索引，如果有，以其为主键(选择建表时定义的第一个唯一非空索引为主键)
- 如果没有，自动创建一个6字节大小的指针。

#### innoDB存储支持的索引

1. B+树索引
2. 全文索引
3. 哈希索引

其中哈希索引是自适应的，不能人为干预。

myISAM和innoDB的索引都采用B+树结构。B树和B+树的讲解：↓

[B树和B+树](https://www.cnblogs.com/nullzx/p/8729425.html)

B+树索引是目前最常用最有效的索引。B+树索引不能找到给定键值的具体行，只能找到被查询数据所在的页。数据库通过把页读入内存，在内存中进行查找，最后找到要查找的数据。

在数据库中，B+树的高度一般在2到4层。

数据库中的B+树索引可以分为聚集索引(clustered index)和辅助索引(secondary indel)。聚集索引和辅助索引的不同在于叶子节点存放的是否是一整行的信息。

#### 聚集索引

聚集索引是按照每张表的主键构建一棵B+树，同时叶子节点中存放的即是整张表的行记录数据，因此也将聚集索引的叶子节点称为数据项。这个特性决定了索引组织表中的数据也是索引的一部分。

每张表只能有一个聚集索引。多数情况下，由于聚集索引是有序的，并且能够在B+树索引的叶子节点上直接找到数据，查询优化器倾向于采用聚集索引。

聚集索引对逐渐的排序查找和范围查找效率非常高。

#### 辅助索引(非聚集索引)

辅助索引的叶子节点并不包含行记录的全部数据。叶子节点除了包含键值之外，每个叶子节点的索引行包含了一个书签，通过书签告诉innoDB存储引擎可以在哪里找到与索引相对应的数据。

每张表上可以有多个辅助索引。通过辅助索引查找数据时，innoDB存储引擎先遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，再通过主键索引找到一行完整的记录。

#### 联合索引

联合索引是指对表上的多列进行索引。

使用联合索引要遵循最左匹配原则

#### 覆盖索引

如果二级索引中包含了查询所需的数据，那么久不需要再去聚集索引中查找了。

覆盖索引指的是一个查询语句只需要从辅助索引中就能够取得要查询的记录，不需要查询聚集索引中的记录。好处是辅助索引不包含整行记录信息，因此其大小远小于聚集索引，可以减少大量的IO操作。

#### 优化器选择不使用索引的情况

对于不能使用覆盖索引的情况，优化其选择辅助索引的条件是：通过辅助索引查找的数据是少量的。因为顺序读的效率远高于随机读。

#### 哈希索引

innoDB存储引擎使用哈希算法对字典进行查找，冲突解决机制采用链表方式，哈希函数采用除法散列。

哈希表的大小一般采用大于页数两倍的最小的质数。

#### 全文检索(Full-Text Searcn)

全文检索指将存储在数据库中的整本书或整篇文章的任意内容查找出来的技术。innoDB从MySQL5.6开始支持全文索引。

$$
MATCN() ... AGAINST()
$$

MATCH指定要查询的列，AGAINST指定查询方法

MySQL有三种类型的全文检索：

1. 自然语言检索
	默认类型，查询带有指定word的文档。
	在where中使用match，查询结果是根据相关性排序的。相关性的计算条件：
	- word是否在文档中出现
	- word出现的次数
	- word在索引列中的数量
	- 多少个文档包含该word
2. 布尔检索
	使用一些特定意义的操作符，如+、-等
3. 查询扩展检索
	是自然语言检索的一个变种，当查询短语太短时有用，是在自然语言检索的基础上，将最相关行中的词添加到查询字符串中进行二次检索。

# 锁

