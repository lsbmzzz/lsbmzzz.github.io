---
layout:     post
title:      Java设计模式
subtitle:   Java设计模式
date:       2019-10-03
author:     正版慕言
header-img: img/blog_bg_1.jpg
catalog: true
mathjax: true
tags:
    - Java设计模式

---

设计模式是针对某一类问题的最优解决方案，是从许多优秀的软件系统中总结出的。

设计模式可以分成创建型、结构型、行为型三大类

# 创建型模式

创建型模式涉及到对象的实例化，用于解耦对象的实例化过程。

#### 简单工厂模式

用一个工厂类专门负责生产对象。里面有一个静态方法根据不同的参数返回来自同一个父类的不同实例对象。

#### 工厂模式

定义了一个创建对象的接口，但由子类决定要实例化的类(将实例化推迟到子类)。

步骤：
- 第一步：选择合适的工厂
- 第二步：生产对象

当需要增加一个新的产品时，我们只需要增加一个具体的产品类和与之对应的具体工厂即可，无须修改原有系统。同时在工厂方法模式中用户只需要知道生产产品的具体工厂即可，无须关系产品的创建过程。

![工厂模式](/img/Journal/设计模式/工厂模式.png)

#### 抽象工厂模式

提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类。

优点是隔离了具体类的生成，使得客户端不需要知道什么被创建了，与具体的产品解耦。

缺点是新增产品对象时，要更改接口和其下的所有子类。

![抽象工厂模式](/img/Journal/设计模式/抽象工厂模式.png)

#### 单例模式

确保每个类只有一个实例，并提供一个全局访问点。

特点：只有一个实例，自我实例化，提供全局访问点

优点：节约系统资源，提高效率，也能严格控制对它的访问。
缺点：单例类职责过重，违背单一职责原则。扩展较为困难

![单例模式](/img/Journal/设计模式/单例模式.png)

#### 建造者模式

讲一个复杂对象的构建和表示分离，使同样的构建过程可以创建不同的表示。适合产品对象内部结构复杂的场景。

建造者模式将复杂产品的构建过程分解到不同的方法中，同时它隔离了复杂产品对象的创建和使用，使得相同的创建过程能够创建不同的产品。

如果某个产品内部过于复杂，就会让系统变得庞大不容易控制。当多个产品之间差异较大，也不适合使用建造者模式。

![建造者模式](/img/Journal/设计模式/建造者模式.png)

#### 原型模式

对象的结构比较复杂，有需要频繁使用他们时，就是用原型模式来对这个对象进行克隆。

原型模式就是用原型实例指定创建对象的种类，并通过复制这些原型来创建新对象。

原型模式简化了新对象的创建过程，并简化了创建结构。

![原型模式](/img/Journal/设计模式/原型模式.png)

# 结构型模式

结构型模式涉及到如何组合类和对象以形成更大的结构。和类有关的结构型模式涉及如何合理使用继承机制，和对象有关的结构型模式涉及如何合理的使用对象组合机制。

#### 代理模式

用一个代理来隐藏具体实现类的实现细节，用这个代理来控制对原对象的引用(中介作用)。

![代理模式](/img/Journal/设计模式/代理模式.png)

#### 适配器模式

如果需要让两个不同接口的类进行通信，在不修改这两个的前提下我们可能会需要某个中间件来完成这个衔接的过程。这个中间件就是适配器。

所谓适配器模式就是将一个类的接口，转换成客户期望的另一个接口。它可以让原本两个不兼容的接口能够无缝完成对接。

适配器将目标类和适配者进行了解耦，增加了类的透明性和可复用性。

![适配器模式](/img/Journal/设计模式/适配器模式.png)

#### 桥接模式

桥接模式就是将抽象部分和它的实现部分隔离开来，使得他们能够独立变化。

![桥接模式](/img/Journal/设计模式/桥接模式.png)

#### 组合模式

组合多个对象形成树形结构以表示“整体-部分”的结构层次。

组合模式最关键的地方：叶子对象和组合对象要实现相同的接口。

![组合模式](/img/Journal/设计模式/组合模式.png)

#### 装饰者模式

装饰者模式将职责动态附加到对象身上。当扩展功能时，装饰者提供了比继承更有弹性的替代方案。

装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。

![装饰模式](/img/Journal/设计模式/装饰模式.png)

#### 外观模式

外观模式提供一个统一的接口，用来访问子系统中的各个接口。

它让一个应用程序中子系统之间的依赖关系减少到了最小，给子系统提供了一个简单的、单一的屏障。

它实现了客户和子系统之间的松耦合，但增加新的子系统可能需要修改外观类或客户端的源码，违背了开闭原则。

![外观模式](/img/Journal/设计模式/外观模式.png)

#### 亨元模式

享元模式对对象的重用提供了一种解决方案，用共享技术对相同或相似的对象实现重用，解决内存占用过多的问题。

亨元模式要求共享的对象必须是细粒度对象。它使对象个数大大减少。

亨元模式使用了内部状态和外部状态，外部状态相对独立，不影响内部状态，因此可以在不同环境下共享对象。但让系统更加复杂。

![亨元模式](/img/Journal/设计模式/亨元模式.png)

# 行为型模式

行为型模式涉及到如何合理的设计对象之间的交互通信，怎样合理为对象分配职责

#### 策略模式

定义算法族，分别封装起来，让它们之间能够互相转换。

策略模式不关心什么算法用于什么问题，策略的选择由用户来做。

用户可以在不修改原有系统的基础上选择算法或行为，也可以增加新的算法或行为。完美符合开闭原则。

![策略模式](/img/Journal/设计模式/策略模式.png)

#### 观察者模式

定义了对象之间的一对多模式，当一个对象状态改变时，其所有依赖者会收到通知并自动更新。

![观察者模式](/img/Journal/设计模式/观察者模式.png)

#### 模板模式

做某几件事情的步骤都差不多，仅有那么一小点的不同。可以将这些步骤分解、封装起来，然后利用继承的方式来继承即可，当然不同的可以自己重写实现。这就是模板模式。

![模板模式](/img/Journal/设计模式/模板模式.png)

#### 责任链模式

它将对象组成一条链，发送者将请求发给链上的第一个接收者，并沿着这条链传递直到有一个对象来处理它或者最后没有对象处理而留在链的末尾。

- 优点：简化了对象结构，每个对象只要引用它的后继。
- 缺点：不能保证所有的请求都能够被处理，而且不利于观察运行时特征。

![责任链模式](/img/Journal/设计模式/责任链模式.png)

#### 状态模式

状态模式就是允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。

状态模式会增加类或者对象的个数。

状态模式将所有与某个状态相关的行为封装到一个类中，并可以方便的增加新状态。只要改变状态就可以改变对象的行为，但这样做会导致系统的结构和实现都比较复杂，不利于维护。

![状态模式](/img/Journal/设计模式/状态模式.png)

