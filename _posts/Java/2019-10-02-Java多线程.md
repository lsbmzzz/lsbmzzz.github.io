---
layout:     post
title:      Java多线程
subtitle:   Java多线程
date:       2019-10-02
author:     正版慕言
header-img: img/blog_bg_1.jpg
catalog: true
mathjax: true
tags:
    - Java

---

# 进程 线程 协程

进程是程序运行和资源分配的基本单位，执行过程中有独立的内存单元。

线程属于进程，共享内存进程的内存地址空间，几乎不占有系统资源。

协程属于线程，在线程内运行，因此又称为微线程。协程没有上下文切换消耗，其调度切换是用户手动切换的，操作具有原子性。

# 守护线程

Java中有用户线程和守护线程两种。

只要有用户线程没有结束，守护线程就全部工作。最后一个用户线程结束时，守护线程和JVM一起结束。典型的守护线程是GC。

# 多线程的上下文切换

多线程的上下文切换是CPU控制权由一个正在运行的线程切换到另一个就绪线程的过程。

# 两种创建线程的方式及其区别

通过实现java.lang.Runnable和通过扩展java.lang.Thread类两种。

相比扩展Thread，实现Runnable接口有两个好处：
- Java不支持多继承，而Runnable接口的类可以扩展另一个类
- 类可能只要求可执行，因此集成整个Thread类的开销过大。

# Thread类中的start()和run()的区别

start创建一个新线程，run只会在原来的线程中调用，没有新县城创建。

# 检测一个线程是否持有对象监视器

Thread类提供了一个holdsLock(Object obj)方法

# Callable和Future，FutureTask

Callable在JUC包里，只声明了call()一个方法。是一个泛型接口，返回的类型就是传进的类型。

Future用来对具体的Runnable或Callable任务的执行结果进行取消、查询是否完成、获取结果。Future接口声明了cancel、isCancelled、isDone、get()、get(long timeout, TimeUnit unit)五个方法，可以判断任务是否完成、中断任务、获取执行结果。

Future是一个接口，无法直接创建对象使用，因此有了FutureTask。FutureTask也是Runnable接口的实现类。

# Runnable和Callable的区别

Runnable的run()返回是void，Callable的call()有返回值。
在多线程中，可以获取到多线程运行的结果。

# 导致线程阻塞的原因

阻塞指的是暂停一个线程的执行以等待某一条件。

Java提供的方法：

|方法|说明|
|---|---|
|sleep()|指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU时间，指定的时间一过，线程重新进入可执行状态。|
|suspend()和resume()|两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume()被调用，才能使得线程重新进入可执行状态。|
|yield()|使当前线程放弃当前已经分得的CPU时间，但不使当前线程阻塞，即线程仍处于可执行状态，随时可能再次分得CPU时间|
|wait()和notify()|两个方法配套使用，wait()使得线程进入阻塞状态，它有两种形式，一种允许指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的notify()被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的notify()被调用|

# wait(),notify()和suspend(),resume()的区别

核心区别在于wait()和notify()在阻塞时会释放占用的锁，而其他方法都不会。

1. wait()和notify()方法属于Object类，其他方法属于Thread()类。
2. wait()和notify()方法必须在synchronized中调用

notify()方法解除阻塞的线程时从因调用该对象的wait()方法而阻塞的线程中随机选择的。notifyAll()将所有阻塞的线程全部解除阻塞，但只有获得锁的线程进入可执行状态。

# synchronized和ReentrantLock的区别

synchronized是关键字， ReentrantLock是类，ReentrantLock比synchronized具有更多更灵活的特性，可以被继承、有方法和类变量。

# Java中的锁类型

- 自旋锁
- 偏向锁
- 轻量级锁

# ThreadLocal

线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。
ThreadLocal就是一种以空间换时间的做法在每个Thread里面维护了一个ThreadLocal.ThreadLocalMap把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。

# 生产者-消费者

# 线程池

使用线程池可以避免频繁创建和销毁线程，达到线程重用。另外使用线程池还可以根据目的灵活控制并发数目。

# Thread.sleep(0)的作用

Java中用到的线程调度算法是抢占式的，会出现某条线程频繁获得CPU的情况。为了让优先级较低的线程也能获得CPU，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作。

# ConcurrentHashMap

CuncurrentHashMap在jdk1.6和jdk1.8中的实现不同。

在1.6中，采用分离锁的方式，对hash表进行局部锁定。具体的，在ConcurrentHashMap内部有一个segment。ConcurrentHashMao的并发度就是segment的大小，默认是16。

在1.8中，不再使用segment分离锁，而是采用乐观锁CAS算法实现同步。底层还是“数组+链表->红黑树”

