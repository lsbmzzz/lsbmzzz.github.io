---
layout:     post
title:      MySQL相关
subtitle:   MySQL相关
date:       2019-09-03
author:     正版慕言
header-img: img/blog_bg_1.jpg
catalog: true
mathjax: true
tags:
    - MySQL

---

# 数据库范式

1. 第一范式(1NF)无重复的列：数据库中每一列都是不可分割的基本数据项。某种属性有多个值时，必须拆分为不同属性。不满足1NF的数据库不是关系数据库。
2. 第二范式(2NF)在1NF的基础上，属性完全依赖于主键：要求记录有唯一标识，通俗的说要有主键ID。
3. 第三范式(3NF)在2NF的基础上，消除传递依赖：是对字段冗余性的约束，任何字段不能由其它字段派生出来。
4. BCNF：在3NF的基础上，主属性不依赖于主属性。

# MySQL事务

MySQL事务可以理解为一系列的操作。一个事务要么成功执行，要么失败。

事务的特性：

1. 原子性：事务开始后的所有操作，要么全部完成，要么全部不做。事务执行过程中如果出错，会回滚到开始前的状态。
2. 一致性：事务开始前和结束后，数据库的完整性约束没有被破坏。比如A转账给B，不可能A转出了，B却没收到。
3. 隔离性：同一时间只允许一个事务请求同一数据，不同的事务之间彼此没有干扰。
4. 持久性：事务完成后，事务对数据库的所有更新将被保存到数据库且不能回滚。


# 事务的并发问题

1. 丢失更新
第一类丢失更新：事务A撤销时，把已经提交的事务B的更新数据覆盖了。导致B虽然成功了，但是它所做的更新没有被永久存储。
第二类丢失更新：两个或多个事务查询同一个数据，然后基于自己查询的结果更新数据，会造成最后一个提交的更新事务覆盖其他已提交的更新事务。

2. 脏读：事务A读取了事务B更新的数据，而事务B回滚了，A读取到的就是脏数据。
3. 不可重复读：事务A多次读取同一数据，事务B在事务A多次读取过程中对数据做了更新并提交了，导致A多次读取的同一数据结果不一致。
4. 幻读：事务A在修改数据库的时候，事务B插入了一条记录，导致A修改结束后发现还有一条记录没有被修改，就像产生了幻觉，所以叫幻读。

#### 事务隔离级别

1. 串行化(serializable)：数据库系统使用串行化隔离时，操作相同数据的两个事务是串行方式运行的。
2. 可重复读(repeatable read)：使用该级别时，一个事务在执行过程中可以看到其他事务已提交的新插入的记录，但不能看到其他事务提交的对已有记录的更新。
3. 读已提交数据(read committed)：当使用该级别时，一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，还能看到其他事务已提交的对已有记录的更新。
4. 读未提交数据(read uncommitted)：使用该级别时，一个事务在执行过程中可以看到其他事务没有提交的新插入的记录，还可以看到其他事务没有提交的对已有记录的更新。

这四种隔离级别等级排序从高到低。

| 事务隔离级别 | 脏读 | 不可重复读 | 幻读 |
| --- | --- | --- | --- |
| 读未提交(read uncommitted) | 是 | 是 | 是 |
| 不可重复读(read commited) | 否 | 是 | 是 |
| 可重复读(repeatable-read) | 否 | 否 | 是 |
| 串行化(serializable) | 否 | 否 | 否 |

MySQL默认的事务隔离级别为可重复读repeatable-read。

# 多版本并发控制MVCC

MVCC是一种用来解决读-写冲突的无锁并发控制。为事务分配单向增长的时间戳，每次修改保存一个版本。读操作只读该事务开始前的数据库快照，避免了脏读和不可重复读。

MVCC数据库更新一条数据时，不直接重写原始数据，而是修改新创建的副本，因此会有多个版本的数据被保存下来。每个事物看到的版本由隔离级别决定。MVCC最通用的隔离级别是快照隔离，在这种情况下事务只会读取到数据在事务开始前的状态。

# MySQL索引

索引是数据库管理系统中一个排序的数据结构，协助快速查询、更新数据库表中的数据。通常使用B+树。

根据局部性原理，为了减少IO操作，磁盘读取每次都会预读，大小通常为一页的整数倍。

B树：所有键值分布在整棵树中，任何一个关键字只出现在一个节点中，搜索可能会在非叶子节点结束
B+树：所有关键字只存在叶子节点

MySQL索引使用B+树和局部性原理有关：由于B+树的内部节点不存储数据，因此一页中可以存储更多内部节点，从而减少对磁盘的访问。另外B+树的叶子节点是相连的，因此遍历整棵树只要一次线性的遍历叶子节点，便于区间查找。

# 聚簇索引

对磁盘上的数据重新组织，使其和索引的顺序一致(局部性原理)。

# 联合索引

两列或更多列上的索引称为联合索引，又叫复合索引。对于联合索引key index(a,b,c)，MySQL会从左到右的使用索引中的字段，一次查询可以只用索引中的一部分，但只能用最左侧的部分。例如，可以用(a),(a,b),(a,b,c)。

#### 联合索引的规则：

1. 需要加索引的字段要在where条件中
2. 数据量少的字段不用加索引
3. 如果where条件中是or的关系，索引不起作用
4. 符合最左原则

创建索引：
ALTER TABLE table_name ADD INDEX index_name(column_list)
ALTER TABLE table_name ADD UNIQUE(column_list)
ALTER TABLE table_name ADD PRIMARY KEY(column_list)

CREATE INDEX index_name ON table_name(column_list)
CREATE UNIQUE INDEX index_name ON table_name(column_list)

删除索引

DROP INDEX index_name ON table_name
ALTER TABLE table_name DROP INDEX index_name
ALTER TABLE table_name DROP PRIMARY KEY

查看索引

show index from table_name

# 唯一索引和主键索引

唯一索引要求索引的数据列不能包含重复值。

好处：
1. 简化MySQL对索引的管理，该索引也因此而更有效率。
2. 插入数据时，如果检查到有重复，则不会插入。

主键索引是唯一索引的一个特殊类型。

1. 如果设置了主键，MySQL会自动创建主键索引。
2. 主键可以作为外键，而唯一索引不可以
3. 主键不能为null，唯一索引可以
4. 每个表只能有一个主键索引

# 模糊查询like

like的匹配条件有四种：

1. %：表示匹配任意个字符
2. _：表示匹配任意单个字符
3. []：表示匹配[]内的任意一个字符
4. [^]：表示取反，查询出不是这些匹配的数据

# 多表查询

交叉连接、内连接、外连接、左连接、右连接、联合查询、全连接

练习网站：[在线SQL - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1177760294764384/1179611432985088)

交叉连接：没有任何限制条件的连接方式称为交叉连接。

select * from students cross join classes 

内连接：两张表中同时符合某种条件的记录的组合。查询到交集

select * from students inner join classes on students.class_id = classes.id

用on指明连接条件

外连接left join：查找出左侧表中的所有记录和两个表的交集

select * from students left outer join classes on students.class_id = classes.id

外连接right join：和left join同理

联合查询union：将两个查询结果放在一起

select * from classes union select * from students

使用union时，两个语句查询出的字段数量要相同。

联合查询union all：不合并重复的记录

乱入：一个group by查询：select class_id, name, score from students s1 where score = (select max(s2.score) from students s2 where s1.class_id = s2.class_id)

# 分库 分表

分表：对于访问频繁和数据量巨大的表，分表可以减少表的记录数，以减少查询时间，提高数据库性能。

分库：对数据库进行拆分，提高并发能力。

# 数据库存储引擎

#### myISAM

myISAM是MySQL的默认引擎，不支持事务。
myISAM更新时锁定整张表。锁的机制成本低，但降低了并发性能。
读写互相阻塞，读与读不阻塞。适合读业务比较多的环境
数据文件和索引文件是分开的

#### InnoDB

支持事务，适合插入和更新比较多的场景，适合大数据和高并发。
锁的级别是行锁(最大的区别)
数据和索引存在同一个表空间里，但可以由多个文件组成

# XSS、SQL和CSRF攻击

XSS是向网页中注入恶意脚本，在用户浏览网页时在用户浏览器中执行恶意脚本。防止方法：做数据校验和标签转换

SQL注入攻击是服务器使用请求参数构造SQL语句时用恶意的SQL嵌入到SQL语句中。防止方法：输入校验，不要动态拼接SQL，用参数化的SQL

CSRF（跨站请求伪造）攻击是攻击者通过跨站请求以合法身份进行非法操作，原理是用浏览器的cookie或服务器的session盗取用户身份。防止方法：用post代替get，清除cookie