---
layout:     post
title:      Java 反射
subtitle:   Java 反射
date:       2019-11-26
author:     正版慕言
header-img: img/blog_bg_1.jpg
catalog: true
mathjax: true
tags:
    - Java

---

所有技术实现的目标只有一点：重用性。

> **"反"与"正"**
> 
> "正"指我们要使用一个类时，要先导入程序所在的包，然后根据类进行对象实例化，并依靠对象调用类中的方法。
> 
> "反"指根据实例化对象反推出其类型。

# 反射机制

实现反射操作，要采用Object类中提供的操作方法：
- 根据实例化对象获得其所属类型：public final Class<?> getClass();

反射的所有核心操作是通过Class类对象展开的。

类定义：
```java
public final class Class<T> extends Object implements Serializable, GenericDeclaration, Type, AnnotatedElement
```

获取Class类的实例化对象可以采用三种方式：
- Object类支持：Object可以根据实例化对象获取Class对象：getClass()。
    + 如果只是想获得Class对象，则必须产生指定类对象后才能获得。
- JVM直接支持：采用类.class的形式直接实例化。
    + 不需要产生指定类对象
    + 必须导入程序对应的开发包才能使用
- Class类支持：Class类中提供了一个静态方法
    + public static Class<?> forName(String className) throws ClassNotFoundException
    + 用法：Class.forName("完整包名");
    + 优点：可以直接采用字符串形式定义目标类型，不需要任何import语句。

# 重点案例

#### 反射实例化对象

获取Class对象最大的意义在于Class中提供的反射实例化方法。

使用反射机制实现对象的实例化：public T newInstance()

用法：
```java
    Class<?> cls = Class.forName("com.lsbmzzz.Person");
    Object obj = cls.newInstance(); //实例化Person
    Object obj2 = cls.getDeclaredConstructor().newInstance();   //JDK1.9之后
```

#### 反射与工厂模式

工厂模式的最大特点：客户程序不直接参与实例化对象，只与接口发生关联，通过工厂类获取指定接口的实例化对象。工厂模式能够解决耦合问题。

一个标准的工厂设计模式案例：
```java
public class Main {
    public static void main(String[] args) {
        IMessage msg = MessageFactory.getInstance("netmessage");
        msg.send();
    }
}

interface IMessage{
    public void send();
}

class NetMessage implements IMessage{
    @Override
    public void send() {
        System.out.println("NetMessage");
    }
}

class MessageFactory{
    private MessageFactory() {
    }
    public static IMessage getInstance(String className){
        if("netmessage".equalsIgnoreCase(className)){
            return new NetMessage();
        }
        return null;
    }
}
```

最主要的缺点：这种工厂设计模式属于静态工厂模式，当追加子类时，一定要修改工厂类。因此不太可能在实际项目中使用。

最好的解决方案是不使用关键字new来完成(new在使用时必须有一个明确的类存在)，使用newInstance()只要有一个明确表示类名称的字符串即可。

工厂类变成：
```java
class MessageFactory{
    private MessageFactory() {
    }
    public static IMessage getInstance(String className){
        IMessage instance = null;
        try{
            instance = (IMessage)Class.forName(className).getDeclaredConstructor().newInstance();
        }catch(Exception e){
            e.printStackTrace();
        }
        return instance;
    }
}
```

这样在追加接口子类时，不再影响工厂类，从而实现工厂类与子类的解耦。

此时仍然具有缺点：在实际开发中，项目中可能存在多个接口。因此我们的工厂类应该可以为所有的接口服务。

解决方案：工厂类使用泛型

最终案例：
```java

public class Main {
    public static void main(String[] args) {
        IMessage msg = Factory.getInstance("NetMessage", IMessage.class);
        msg.send();
        IService sve = Factory.getInstance("NetService", IService.class);
        sve.service();

    }
}

interface IMessage{
    public void send();
}

class NetMessage implements IMessage{
    @Override
    public void send() {
        System.out.println("NetMessage");
    }
}

interface IService{
    public void service();
}

class NetService implements IService{
    @Override
    public void service() {
        System.out.println("NetService");
    }
}

class Factory{
    private Factory() {
    }
    public static <T> T getInstance(String className, Class<T> cls){
        T instance = null;
        try{
            instance = (T)Class.forName(className).getDeclaredConstructor().newInstance();
        }catch(Exception e){
            e.printStackTrace();
        }
        return instance;
    }
}
```

#### 反射与单例模式

单例模式的最大特点是运行过程中只有一个实例化对象。

在多线程环境中，懒汉式单例模式需要进行synchronized同步处理。

Java中使用到单例设计模式的地方：Runtime

```java
public class Main {
    public static void main(String[] args) {
        for(int i = 0; i < 10; i++){
            new Thread(()->{
                Singleton singleton = Singleton.getInstance();
                singleton.print();
            }, "Singleton").start();
        }
    }
}
class Singleton{
    private static volatile Singleton singleton = null;
    private Singleton() {
        System.out.println("Singleton create");
    }
    public void print(){
        System.out.println("hello world");
    }
    public static Singleton getInstance(){
        if(singleton == null){
            synchronized (Singleton.class){
                if(singleton == null){
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```

# 反射与类操作

#### 反射获取类结构信息

> 一个类的基本组成有：父类(父接口)、包、属性、方法(构造方法、普通方法)

- 获取类的基本信息
    + 获取包名称：public Pachage getPackage()
    + 获取父类：public Class<? super T> getSuperClass()
    + 获取父接口：public Class<?>[] getInterfaces()

#### 反射获取构造方法

- 获取所有构造方法：public Constructor<?>[] getDeclaredConstructors()
- 获取指定构造方法(根据参数类型)：public Constructor<T> getDeclaredConstructor(Class<T>...parameterTypes)
- 获取所有构造方法：public Constructor<?>[] getConstructors()
- 获取指定构造方法：public Constructor<T>getConstructor(Class<?>...parameterTypes)

两种获取方法似乎没有区别。。

利用反射机制调用有参构造进行对象实例化：
```java
    Class<?> cls = Person.class;
    Constructor<?> constructor = cls.getConstructor(String.class, int.class);
    Object obj = constructor.newInstance("xiaoqiang", 20);
    System.out.println(obj);
```

在实际开发中所有的类最好都提供无参构造以实现统一性。

#### 反射调用普通方法

前提条件：类中要提供有实例化对象。

Class类中提供的获取方法对象的操作：
- 获取全部方法(包括父类中的方法)：public Method[] getMethods()
- 获取指定方法(包括父类中的方法)：public Method getMethod(String name, Class<?>...parameterTypes)
- 获取本类全部方法：public Method[] getDeclaredMethods()
- 获取本类指定方法：public Method getDeclaredMethod(String name, Class<?>...parameterTypes)

**Method里的一个重要方法：**
- public Object invoke(Object obj, Object... args)

使用method.invoke(obj, value)来调用获得的方法。

#### 反射调用成员

Class类提供了两组方法：
- 获取本类全部成员：public Field[] getDeclaredFields()
- 获取本类指定成员：public Field getDeclaredField(String name)
- 获取父类全部成员：public Field[] getFields()
- 获取父类指定成员：public Field getField(String name)

![反射与类操作](/img/Java开发/反射与类操作.png)

Field中最重要的操作不是获取成员，而是下面的操作：
- 设置属性内容：public void set(Object obj, Object value)
- 获取属性内容：public Object get(Object obj)
- 解除封装：public void setAccessible(boolean flag)

Field类中最常用的方法：获取成员类型
- public Class<?> getType()

#### Unsafe工具类

除了JVM本身提供的反射处理外，Java里也提供了一个Unsafe类。其特点是可以利用反射来获取对象，直接使用底层的C++来代替JVM执行。

如果项目中使用了Unsafe类，将无法使用JVM的内存管理机制和垃圾回收。

如果要十使用Unsafe类，首先要确认这个类中的构造方法与常量

构造方法：
- private Unsafe(){}

常量：
- private static final Unsafe theUnsafe = new Unsafe();

这个类中没有提供static方法。如果要获得该类对象，必须利用反射机制来完成。

如果不是必须的情况下，不建议使用Unsafe。

# 反射与简单Java类

类设计的基本结构：应该由一个专门的ClassInstanceFactory类负责所有反射处理：接收反射对象与我们要设置的属性内容，同时可以获取指定类的实例化对象。

![反射与简单Java类](/img/Java开发/反射与简单Java类.png)

#### 单级属性赋值

![单级属性赋值](/img/Java开发/单级属性赋值.png)

- 定义一个BeanUtils工具类实现属性的设置
- 定义StringUtils实现首字母大写功能
- 定义ClassInstanceFactory类负责实例化对象并调用BeanUtils实现属性内容的设置

可以在BeanUtils类中追加处理方法实现不同类型的内容设置：
- 定义一个private static Object getAttributeValue(String type, String value)方法进行属性转换

#### 级联对象

如果给定的类对象中存在其他引用的级联关系，形成多级的结构。

可使用“.”进行级联关系的处理。但考虑到代码简洁性，应该考虑通过级联配置自动实现类中属性的实例化。

多级配置：获得级联关系，使用循环通过getter方法逐级访问。如对象未实例化，对其进行实例化。

放个案例。。。
```java
import org.omg.PortableInterceptor.SYSTEM_EXCEPTION;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.text.SimpleDateFormat;
import java.util.Date;

public class Main {
    public static void main(String[] args) {
        String value = "empno:1001|ename:张三|job:客服|salary:750.25|hireDate:2001-09-11|dept.dname:客服部|dept.loc:北京市|dept.company.name:MLDN";
        Emp emp = ClassInstanceFactory.create(Emp.class, value);
        System.out.println(emp.toString());
    }
}

class ClassInstanceFactory{
    private ClassInstanceFactory(){}

    public static <T> T create(Class<?> clazz, String value){
        try{
            Object object = clazz.getDeclaredConstructor().newInstance();
            BeanUtils.setValue(object, value);
            return (T) object;
        }catch (Exception e){
            e.printStackTrace();
            return null;
        }
    }
}

class StringUtils{
    public static String initcap(String str){
        if(str == null || "".equals(str)){
            return str;
        }else if(str.length() == 1){
            return str.toUpperCase();
        }
        return str.substring(0, 1).toUpperCase() + str.substring(1);
    }
}

class BeanUtils{
    private BeanUtils(){}

    public static void setValue(Object object, String value){
        String[] results = value.split("\\|"), attrs;
        Field tmpField;
        Method tmpMethod;
        String attr, tmpAttr;

        for(String result : results){
            attrs = result.split(":");
            attr = attrs[0];
            try{
                if(attr.contains(".")){
                    String[] tmps = attr.split("\\.");
                    Object currentObject = object;
                    for(int i = 0; i < tmps.length - 1; i++){
                        Method getMethod = currentObject.getClass().getDeclaredMethod("get" + StringUtils.initcap(tmps[i]));
                        Object tmpObject = getMethod.invoke(currentObject);
                        if(tmpObject == null){
                            Field field = currentObject.getClass().getDeclaredField(tmps[i]);
                            Method setMethod = getDeclaredMethod(currentObject.getClass(), "set", tmps[i], field.getType());
                            Object newObject = field.getType().getDeclaredConstructor().newInstance();
                            setMethod.invoke(currentObject, newObject);
                            currentObject = newObject;
                        }else {
                            currentObject = tmpObject;
                        }
                    }
                    Field field = currentObject.getClass().getDeclaredField(tmps[tmps.length - 1]);
                    Method setMethod = getDeclaredMethod(currentObject.getClass(), "set", tmps[tmps.length - 1], field.getType());
                    Object valueObject = BeanUtils.convertAttrValue(field.getType().getName(), attrs[1]);
                    setMethod.invoke(currentObject, valueObject);
                }
                else{
                    Field field = object.getClass().getDeclaredField(attr);
                    Method setMethod = getDeclaredMethod(object.getClass(), "set", attr, field.getType());
                    Object valueObject = BeanUtils.convertAttrValue(field.getType().getName(), attrs[1]);
                    setMethod.invoke(object, valueObject);
                }
            }catch (Exception e){
                e.printStackTrace();
            }
        }
    }


    private static Method getDeclaredMethod(Class<?> clazz, String methodNamePrefix, String methodName, Class<?>... parameterTypes){
        try{
            if(methodNamePrefix == null || "".equals(methodNamePrefix)){
                return clazz.getDeclaredMethod(methodName, parameterTypes);
            }
            return clazz.getDeclaredMethod(methodNamePrefix + StringUtils.initcap(methodName), parameterTypes);
        }catch (Exception e){
            e.printStackTrace();
            return null;
        }
    }

    private static Object convertAttrValue(String type, String value){
        switch (type){
            case "java.lang.Long":
            case "long":
                return Long.valueOf(value);
            case "java.lang.Integer":
            case "int":
                return Integer.valueOf(value);
            case "java.lang.Double":
            case "double":
                return Double.valueOf(value);
            case "java.util.Date":
                String pattern = null;
                if(value.matches("\\d{4}-\\d{2}-\\d{2}")){
                    pattern = "yyyy-MM-dd";
                }else if(value.matches("\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}")) {
                    pattern = "yyyy-MM-dd HH:mm:ss";
                }
                if(pattern != null){
                    try {
                        return new SimpleDateFormat(pattern).parse(value);
                    }catch (Exception e){
                        e.printStackTrace();
                    }
                }
                return new Date();
        }
        return value;
    }

}

class Company{
    private String name;
    private Date createdate;

    public Company() {
    }

    public Company(String name, Date createdate) {
        this.name = name;
        this.createdate = createdate;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Date getCreatedate() {
        return createdate;
    }

    public void setCreatedate(Date createdate) {
        this.createdate = createdate;
    }

    @Override
    public String toString() {
        return "Company{" +
                "name='" + name + '\'' +
                ", createdate=" + createdate +
                '}';
    }
}

class Dept{
    private String dname;
    private String loc;
    private Company company;

    public Dept() {
    }

    public Dept(String dname, String loc, Company company) {
        this.dname = dname;
        this.loc = loc;
        this.company = company;
    }

    public String getDname() {
        return dname;
    }

    public void setDname(String dname) {
        this.dname = dname;
    }

    public String getLoc() {
        return loc;
    }

    public void setLoc(String loc) {
        this.loc = loc;
    }

    public Company getCompany() {
        return company;
    }

    public void setCompany(Company company) {
        this.company = company;
    }

    @Override
    public String toString() {
        return "Dept{" +
                "dname='" + dname + '\'' +
                ", loc='" + loc + '\'' +
                ", company=" + company +
                '}';
    }
}

class Emp{
    private Long empno;
    private String ename;
    private String job;
    private Double salary;
    private Date hireDate;
    private Dept dept;

    public Emp() {
    }

    public Emp(Long empno, String ename, String job, Double salary, Date hireDate, Dept dept) {
        this.empno = empno;
        this.ename = ename;
        this.job = job;
        this.salary = salary;
        this.hireDate = hireDate;
        this.dept = dept;
    }

    public Long getEmpno() {
        return empno;
    }

    public void setEmpno(Long empno) {
        this.empno = empno;
    }

    public String getEname() {
        return ename;
    }

    public void setEname(String ename) {
        this.ename = ename;
    }

    public String getJob() {
        return job;
    }

    public void setJob(String job) {
        this.job = job;
    }

    public Double getSalary() {
        return salary;
    }

    public void setSalary(Double salary) {
        this.salary = salary;
    }

    public Date getHireDate() {
        return hireDate;
    }

    public void setHireDate(Date hireDate) {
        this.hireDate = hireDate;
    }

    public Dept getDept() {
        return dept;
    }

    public void setDept(Dept dept) {
        this.dept = dept;
    }

    @Override
    public String toString() {
        return "Emp{" +
                "empno=" + empno +
                ", ename='" + ename + '\'' +
                ", job='" + job + '\'' +
                ", salary=" + salary +
                ", hireDate=" + hireDate +
                ", dept=" + dept +
                '}';
    }
}
```

