---
layout:     post
title:      JavaWeb三大组件
subtitle:   JavaWeb三大组件
date:       2019-12-09
author:     正版慕言
header-img: img/blog_bg_1.jpg
catalog: true
mathjax: true
tags:
    - Java

---

> JavaWeb的三大组件：
> - Servlet
> - Listener
> - Filter

# Servlet

> Servlet属于动态资源。作用是处理服务器接收到的请求。

Servlet中通常需要：
- 接收请求数据
- 处理请求
- 完成响应

#### Servlet接口

**实现Servlet的方式**
- 实现javax.servlet.Servlet接口
- 继承javax.servlet.GenericServlet类
- 继承javax.servlet.http.HttpServlet类

通常会继承HTTPServlet类来完成。

Servlet接口定义
```java
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

package javax.servlet;

import java.io.IOException;

public interface Servlet {
    //生命周期方法，可调用一次
    void init(ServletConfig var1) throws ServletException;
    //获取Servlet配置信息
    //一个ServletConfig对象对应了web.xml中一个Servlet的配置信息
    ServletConfig getServletConfig();
    //生命周期方法，可调用多次
    //每一次请求的处理都调用这个方法
    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;
    //获取Servlet信息
    String getServletInfo();
    //生命周期方法，可调用一次
    void destroy();
}
```

通常其中的方法多数(生命周期方法)由Tomcat来调用，对象也由Tomcat来创建。

生命周期方法：
- void init(ServletConfig var1) 创建时立刻执行
- void service(ServletRequest var1, ServletResponse var2) 每次处理请求时被调用
- void destroy() 销毁时执行

**Servlet特性：**
- 遵循单例模式
- 效率高，线程不安全
    + 尽量不要创建成员，使用局部变量即可
    + 可创建无状态成员或只读状态的成员

在web.xml中可以配置<load-on-startup>num</load-on-startup>，num为一个非负数的值。让服务器在启动时就创建Servlet。多个Servlet按照num从小到大的顺序创建。

一个Servlet可以给出多个<url-patern></url-patern>

#### ServletConfig接口

ServletConfig接口定义
```java
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

package javax.servlet;

import java.util.Enumeration;

public interface ServletConfig {
    //获得<servlet-name>中的内容
    String getServletName();
    //获取Servlet上下文对象
    ServletContext getServletContext();
    //通过名称获取指定初始化参数的值
    String getInitParameter(String var1);
    //获取所有初始化参数的名称
    Enumeration<String> getInitParameterNames();
}

```

案例
```java
package com.lsbmzzz;

import javax.servlet.*;
import java.io.IOException;
import java.util.Enumeration;

public class Demo1 implements Servlet {
    @Override
    public void init(ServletConfig servletConfig) throws ServletException {
        System.out.println("init");
        System.out.println(servletConfig.getInitParameter("p1"));
        Enumeration enumeration = servletConfig.getInitParameterNames();
        while(enumeration.hasMoreElements())
            System.out.println(enumeration.nextElement());

    }

    @Override
    public ServletConfig getServletConfig() {
        return null;
    }

    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        System.out.println("service");

    }

    @Override
    public String getServletInfo() {
        return null;
    }

    @Override
    public void destroy() {
        System.out.println("destory");
    }
}

```

#### GenericServlet类

Servlet接口的抽象类，为Servlet接口中的一些方法做了空实现，只将service()方法作为抽象方法。

#### HttpServlet

只需覆写doGet()和doPost()方法。

[HttpServlet时序图](/img/Java开发/HttpServlet时序图.png)

#### ServletContext

> **一个项目只有一个ServletContext对象**
> 
> 可以在N个Servlet中获取这个唯一对象，可以用它给多个Servlet传递数据。
> 
> 在Tomcat启动时创建，Tomcat关闭时才结束。

**获取ServletContext**

使用ServletConfig提供的getServletContext()方法
- GenericServlet或HttpServlet类getServletConfig().getServletContext()方法(该实现了ServletConfig接口)
- 在init(ServleetConfig servletConfig)方法中获得
- ...

**操作域属性**

JavaWeb的四大域对象：
- PageContext
- ServletRequest
- HttpSession
- ServletContext

所有域对象都有存取数据的功能，其中有一个Map用来存储数据。

ServletContext是JavaWeb四大域对象之一。

ServletContext操作数据的方法：

|方法|功能|
|---|---|
|void setAttribute(String name, Object value)|存储一个对象(域属性)|
|Object getAttribute(String name)|获取数据|
|void removeAttribute(String name)|溢出域属性|
|Enumeration getAttributeNames()|获取所有域属性的名称|

**获取应用初始化参数**

一个Servlet只能获取自己的初始化参数，不能获取其他Servlet的参数。

可以配置公共的初始化参数供所有Servlet使用，这需要使用ServletContext。
- ServletConfig中提供的方法
    + String getInitParameter(String var1);
    + Enumeration<String> getInitParameterNames();

**获取资源**

- 获取真实路径
    + ServletContext提供的String getRealPath(String var1)方法
- 获取资源流
    + ServletContext提供的InputStream getResourceAsStream(String var1)方法
- 获取指定目录下所有资源路径
    + ServletContext提供的Set<String> getResourcePaths(String var1)方法

以上所有方法中填写的都应是资源在项目中的绝对路径


# Listener

> Listener监听器是一个接口，由我们实现内容。
> 需要注册到组件上。
> 
> 监听器中的方法在特殊事件发生时执行。
> 
> JavaWeb中有8个监听器。

- 事件源：相关的三大域与六大监听器
    + ServletContext
        * 生命周期监听：ServletContextListener
        ```java
        public interface ServletContextListener extends EventListener {
            //出生时调用
            void contextInitialized(ServletContextEvent var1);
            //死亡时调用
            void contextDestroyed(ServletContextEvent var1);
        }
        ```
        * 属性监听：ServletContextAttributeListener
        ```java
        public interface ServletContextAttributeListener extends EventListener {
            //添加属性时调用
            void attributeAdded(ServletContextAttributeEvent var1);
            //移除属性时调用
            void attributeRemoved(ServletContextAttributeEvent var1);
            //替换属性时调用
            void attributeReplaced(ServletContextAttributeEvent var1);
        }
        ```
    + HttpSession
        * 生命周期监听：HttpSessionListener
        ```java
        public interface HttpSessionListener extends EventListener {
            //出生时调用
            void sessionCreated(HttpSessionEvent var1);
            //死亡时调用
            void sessionDestroyed(HttpSessionEvent var1);
        }
        ```
        * 属性监听：HttpSessionAttributeListener
        ```java
        public interface HttpSessionAttributeListener extends EventListener {
            //添加属性时调用
            void attributeAdded(HttpSessionBindingEvent var1);
            //移除属性时调用
            void attributeRemoved(HttpSessionBindingEvent var1);
            //替换属性时调用
            void attributeReplaced(HttpSessionBindingEvent var1);
        }
        ```
    + ServletRequest
        * 生命周期监听：ServletRequestListener
        ```java
        public interface ServletRequestListener extends EventListener {
            //出生时调用
            void requestDestroyed(ServletRequestEvent var1);
            //死亡时调用
            void requestInitialized(ServletRequestEvent var1);
        }
        ```
        * 属性监听：ServletRequestAttributeListener
        ```java
        public interface ServletRequestAttributeListener extends EventListener {
            //添加属性时调用
            void attributeAdded(ServletRequestAttributeEvent var1);
            //移除属性时调用
            void attributeRemoved(ServletRequestAttributeEvent var1);
            //替换属性时调用
            void attributeReplaced(ServletRequestAttributeEvent var1);
        }
        ```
- 实现监听器步骤：
    1. 编写监听器类实现一个监听器接口
    2. 在web.xml中配置
- 事件对象及其获取：
    + ServletContextEvent:
        * public ServletContext getServletContext()
    + HttpSessionEvent:
        * public HttpSession getSession()
    + ServletRequestEvent:
        * public ServletRequest getServletRequest()
        * public ServletContext getServletContext()

    + ServletContextAttributeEvent extends ServletContextEvent:
        * public ServletContext getServletContext()
        * public String getName()
        * public Object getValue()
    + HttpSessionBuildingEvent extends HttpSessionEvent:
        * public HttpSession getSession()
        * public HttpSession getSession()
        * public String getName() 
        * public Object getValue() 
    + ServletRequestAttributeEvent extends ServletRequestEvent:
        * public ServletRequest getServletRequest()
        * public ServletContext getServletContext()
        * public String getName()
        * public Object getValue()

- 感知监听器(用来添加到JavaBean上而不是三大域上，直接在类上实现其接口，不需要在web.xml中配置)：
    + HttpSessionBindingListener：添加到javabean上，javabean就知道自己是否添加到session中了。
    + HttpSessionActivationListener：Tomcat在钝化和活化session时调用。JavaBean需要实现序列化接口才能够被一起序列化到硬盘上。

session序列化：Tomcat服务器关闭时会将session通过序列化的方式存储到硬盘上

session的钝化和活化：长时间无动作的session通过序列化保存到硬盘上，当用户再使用session时，Tomcat还会把钝化的对象再活化session(文件不会消失)。

# Filter

> Filter会在一组资源(jsp, servlet, css, html等)的前面执行，可以控制请求能不能得到目标资源(拦截请求的能力)

过滤器编写：
- 编写一个类实现Filter接口
- 在web.xml中进行配置

Filter是单例的。

Filter接口中需要覆写的三个方法：
|方法|功能|
|---|---|
|public void init(FilterConfig filterConfig)|创建后立即执行|
|public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) |每次过滤时都会执行|
|public void destroy()|销毁前执行|

#### FilterConfig

|方法|功能|
|---|---|
|String getFilterName();|获取过滤器名称|
|ServletContext getServletContext();|获取application|
|String getInitParameter(String var1);|获取初始化参数|
|Enumeration<String> getInitParameterNames();|获取所有初始化参数|

#### FilterChain

只有一个方法：void doFilter(ServletRequest var1, ServletResponse var2)

功能：执行目标资源或下一个过滤器。相当于调用了目标Servlet的service()方法

**多个过滤器的执行顺序**

如果没有下一个过滤器，则执行目标资源。否则，执行下一个过滤器。

#### 四种拦截方式

- 请求REQUEST(默认的拦截方式)
- 转发FORWARD
- 包含INCLUDE
- 错误ERROR

在<filter-mapping>中进行配置:
```xml
<filter-mapping>
    <filter-name>filter</filter-name>
    <url-pattern>/Filter</url-pattern>
    <dispatcher>REQUEST</dispatcher>
</filter-mapping>
```

不写时，默认拦截REQUEST。

#### 使用filter-mapping控制多个Filter的执行顺序

过滤器在<filter-mapping></filter-mapping>中配置的顺序决定了执行的顺序。

#### 应用场景

- 执行目标资源之前做预处理工作，如设置编码等
- 通过条件判断目标资源是否执行，如身份校验、IP校验等
- 在执行目标资源后做一些后续处理工作


