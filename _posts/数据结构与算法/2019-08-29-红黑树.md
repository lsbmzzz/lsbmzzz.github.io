---
layout:     post
title:      红黑树
subtitle:   红黑树
date:       2019-08-29
author:     正版慕言
header-img: img/blog_bg_1.jpg
catalog: true
mathjax: true
tags:
    - 数据结构

---

> 红黑树(Red Black Tree)是一种自平衡的二叉查找树。

# 红黑树的特性

除了符合二叉查找树的基本特性之外，红黑树的特性有：

1. 节点是红色或黑色的
2. 根节点是黑色的
3. 每个叶子节点都是黑色的空节点
4. 每个红色节点的两个子节点都是黑色的
5. 从任一节点到它每个叶子节点的所有路径都包含相同数目的黑色节点

![红黑树](/img/数据结构与算法/红黑树.jpeg)

红黑树从根节点到叶子节点的最长路径不会超过最短路径的2倍。它的平衡性要求比AVL树低，是一种弱平衡二叉树。

当插入删除节点的时候，红黑树的规则可能被打破。这时候，就需要做出一些调整来维持规则。

一棵含有n个节点的红黑树的高度不超过$2log(n+1)$。

高度为h的共黑树，它包含的内节点个数至少为$2^{bh(x)}-1 $个。

我们把黑色节点的个数（黑高）记为$bh(x)$。对一棵红黑树来说，$bh(x) $是唯一的，且$bh(x) >= \frac{h}{2} $。

红黑树的操作：

# 红黑树的插入

在进行插入操作时，我们设定插入的节点颜色为红色。因为如果插入的是黑色节点，就违背了第5条特性。而红色节点的冲突更容易调整。

插入节点分为以下情况：

### 插入节点的父节点为黑色节点

这样的情况不破坏红黑树特性，因此直接插入即可。

![黑父](/img/数据结构与算法/红黑树-黑父.png)

### 插入节点的父节点为红色节点

此时又分为两种情况：

##### 插入节点的叔节点也为红色

此时只要修改父节点和叔节点的颜色为黑色，将祖父节点修改为红色。

此时在当前的子树内每一条路径的黑色节点数目未变，但祖父节点的父节点也有可能是红色，因此要递归向上调整颜色。

![红叔](/img/数据结构与算法/红黑树-红叔.png)

##### 插入节点的叔节点为黑色

此时不能通过修改节点的颜色来达到平衡的效果。

会出现$LL, LR, RR, RL$ 4种插入情况，这四种情况的旋转和AVL树的旋转方法一样，但要在旋转之后需要改变节点的颜色，让旋转后的根节点为黑色，根节点的两个子节点为红色，被旋转到最下方的叔节点不用改变。

1. LL: 先右旋，然后改变节点的颜色
![LL](/img/数据结构与算法/红黑树-LL.png)
2. LR: 先左旋，再右旋，最后改变节点的颜色
![LR](/img/数据结构与算法/红黑树-LR.png)
3. RR: 先左旋，然后改变节点的颜色
![RR](/img/数据结构与算法/红黑树-RR.png)
4. RL: 先右旋，再左旋，最后改变节点的颜色
![RL](/img/数据结构与算法/红黑树-RL.png)

# 红黑树的删除

如果要删除的节点有两个儿子，做法是找到这个节点在中序遍历下的后继，后继结点中的值拷贝到当前节点，然后删除这个后继结点。因为后继结点最多只有一个子节点，因此就可以吧问题转换为删除只有一个孩子或没有孩子的节点。

**下面只讨论待删除的节点只有一个儿子节点的情况。**

### 要删除的节点是红色节点

如果要删除的节点是红色节点，那么它的父亲和儿子一定是黑色的。可以直接用它的儿子节点来替换掉它，并不会破坏红黑树的特性。

### 要删除的节点是黑色节点，但它的儿子是红色节点

这种情况下，我们可以直接用它的红色儿子变成黑色替代它，不会破坏红黑树的特性。

### 要删除的节点是黑色节点，并且它的子节点也是黑色

在这种情况下该节点的两个儿子都是叶子节点。（如果其中一个是叶子节点，另一个是黑色非叶子节点，那么就违反了红黑树的特性。）

我们用$N$表示删除节点的儿子，$S$表示删除节点的兄弟，$P$表示删除节点的父亲。$S_L$为$S$的左儿子，$S_R$为$S$的右儿子。

我们把$N$放在删除节点后的新的位置上。

下面的情况中假设了$N$为左儿子。如果是右儿子，左右对调。

##### 1. 如果$N$是新的根

结束。

##### 2. 如果$S$是红色

这种情况下，对$P$做左旋转，让$S$变成$P$的父亲，然后对调$S$和$P$的颜色。

![2](/img/数据结构与算法/红黑树-删除2.png)

由于删除的节点是黑色节点，所以经过$N$的路径上实际少了一个黑色节点，因此还需要后面继续处理。

变换后$N$有了一个红色的父亲和一个黑色的兄弟，可以参考下面的第4/5/6种情况。

##### 3. $P,S,S_L,S_R$ 都是黑色的

这种情况下，我们将$S$变为红色。这样让当前子树中所有路径都少了一个黑色节点，从而继续保持平衡。

![3](/img/数据结构与算法/红黑树-删除3.png)

但是现在通过$P$的所有路径比不通过$P$的所有路径都少了一个黑色节点，因此还需要在P上做重新平衡处理。

（转到情况1？）

##### 4. $S, S_L, S_R$为黑色，但$P$为红色。

这种情况下，可以交换$S, P$的颜色。

![4](/img/数据结构与算法/红黑树-删除4.png)

##### 5. $S, S_R$是黑色，$S_L$是红色

这种情况下，对$S$做右旋转，然后交换$S, S_L$的颜色。

![5](/img/数据结构与算法/红黑树-删除5.png)

这样让$S_L, N$成为兄弟节点。旋转后所有的路径仍然有同样数目的黑色节点，但让$N$有了一个黑色兄弟，黑色兄弟的右儿子是红色的。进入第六种情况。

结合情况6，这相当于AVL树里的RL旋转。如果方向对调，就是LR旋转。旋转后重新配色。

##### 6. $S$是黑色，$S_R$是红色

这种情况下，对$P$做左旋转，然后交换$P, S$的颜色，并让$S_R$为黑色。

![6](/img/数据结构与算法/红黑树-删除6.png)

这样，通过$N$的路径上增加了一个黑色节点从而弥补了删除的节点；而在不通过$N$的路径上，有两种可能性：

1. 通过$N$的新兄弟：他在以前和现在都通过$S, P$，所以黑色节点数不变
2. 通过$N$的新叔节点：$S_R$由红色变成了黑色，所以黑色节点不变