---
layout:     post
title:      MySQL与InnoDB相关
subtitle:   MySQL与InnoDB相关
date:       2019-10-01
author:     正版慕言
header-img: img/blog_bg_1.jpg
catalog: true
mathjax: true
tags:
    - MySQL

---

# 数据库范式

1. 第一范式(1NF)无重复的列：数据库中每一列都是不可分割的基本数据项。某种属性有多个值时，必须拆分为不同属性。不满足1NF的数据库不是关系数据库。
2. 第二范式(2NF)在1NF的基础上，属性完全依赖于主键：要求记录有唯一标识，通俗的说要有主键ID。
3. 第三范式(3NF)在2NF的基础上，消除传递依赖：是对字段冗余性的约束，任何字段不能由其它字段派生出来。
4. BCNF：在3NF的基础上，主属性不依赖于主属性。

# 事务

MySQL事务可以理解为一系列的操作。一个事务要么成功执行，要么失败。事务是并发控制的基本单位。

#### 事务的特性(ACID)：

1. 原子性(atomicity)：事务开始后的所有操作，要么全部完成，要么全部不做。事务执行过程中如果出错，会回滚到开始前的状态。
2. 一致性(consistency)：事务开始前和结束后，数据库的完整性约束没有被破坏。比如A转账给B，不可能A转出了，B却没收到。
3. 隔离性(isolation)：同一时间只允许一个事务请求同一数据，不同的事务之间彼此没有干扰。
4. 持久性(durability)：事务完成后，事务对数据库的所有更新将被保存到数据库且不能回滚。

#### 事务的隔离级别

|隔离级别|脏读(Dirty Read)|不可重复度(NonRepeatable Read)|幻读(Phantom Read)|
|---|---|---|---|
|读未提交(Read uncommitted)|T|T|T|
|读已提交(read committed)|F|T|T|
|可重复读(Repeatable read)(默认隔离级别)|F|F|T|
|串行化(Serializable)|F|F|F|

#### MySQL的事务实现原理

InnoDB中，事务的隔离性通过锁来实现，原子性、一致性、持久性通过redo log和undo log来实现。redo log称为重做日志，保证事务的原子性和持久性；undo log帮助事务回滚以及MVCC等功能，用来保证事务的一致性。

redo
- 重做日志通过内存中的重做日志缓冲(redo log buffer)和重做日志文件(redo log file)实现。redo log buffer是易失的，redo log file是永久的。
- 事务开始时，事务中的操作都会先写入日志缓冲，在事务提交之前，这些缓冲日志要写入日志文件，然后再提交事务(redo日志比数据先写回磁盘)。
- redo的流程：
1. 原始数据从磁盘读入内存，修改内存拷贝
2. 生成重做日志写入redo log buffer，其记录的是数据被修改后的值
3. 事务commit时，将redo log buffer刷新到redo log file(追加写)
4. 定期将修改的数据刷新到磁盘中

undo
- undo log主要记录的是数据的逻辑变化。在发生错误时想要回滚之前的操作，需要将之前的操作都记录下来。
- undo字段存放在数据库内部的一个特殊字段中，称为undo段。
- undo log的作用：
1. 用于事务回滚(通过回滚操作进而保证了事务的原子性)
2. MVCC(保证一致性)
- undo是逻辑日志，它的回滚是将所有修改逻辑的取消了，但数据结构可能并不相同(以免影响并行的其他事务)。

## 分布式事务

分布式事务指一次大的操作由多个小的操作组成，这些小的操作分布在不同服务器上，属于不同的应用，这些小的操作必须要么全部成功，要么全部失败。(保证不同数据库的数据一致性)

#### CAP定理
	
- C(一致性)：对某个指定的客户端来说，读操作能返回最新的写操作(强一致性)。
- A(可用性)：非故障节点在合理的时间内返回合理的响应。
- P(分区容错性)：当出现网络分区后，系统仍然能够继续工作(如果有一台机器出现问题，这个集群应该仍能够正常工作)。

CAP三者不能共有

理论上不能选择CA架构，只能选择CP或AP架构。
- CP放弃可用性，追求一致性和分区容错性(zookeeper追求强一致)。
- AP放弃一致性(强一致性)，追求分区容错性和可用性，是很多分布式系统设计时的选择。

CAP理论是忽略网络延迟的

#### BASE

BASE 是Basically Available(基本可用)、Soft state(软状态)、Eventually consistent(最终一致性)的缩写。是对CAP中AP的扩展

1. 基本可用(BA)：分布式系统出现故障时，允许损失部分可用功能，保证核心功能可用
2. 软状态(S)：允许系统存在中间状态，不影响系统可用性(指CAP中的不一致)
3. 最终一致(E)：指经过一段时间后，所有节点数据都将会达到一致

BASE和ACID相反，它通过牺牲强一致性来获得可用性，允许数据在一段时间内不一致，但最终达到一致状态。

分布式事务协议：两段提交协议2PC、三段提交协议3PC等

两段提交协议2PC：
1. 投票阶段
2. 提交执行阶段

三段提交协议3PC：
1. CanCommit阶段
2. PreCommit阶段
3. doCommit阶段

↓

[常用的分布式事务解决方案](https://juejin.im/post/5aa3c7736fb9a028bb189bca)

# 约束和视图

数据的完整性指数据的正确性和一致性。

#### 数据完整性有三种形式

1. 实体完整性保证表中有一个主键(primary key或unique key,或触发器)
2. 域完整性保证数据每列的值满足一定的条件(选择合适的数据类型、外键、触发器等)
3. 参照完整性保证两表之间的关系(外键、触发器)

#### InnoDB提供的约束

1. primary key
2. unique key
3. foreign key
4. default 插入默认值
5. not null 非空

约束与索引的区别：约束是一个逻辑的概念，用来保证数据完整性；索引是一种物理结构。

#### enum和set约束

指定字段只能取一系列给定的值。

enum的值必须是指定的字符类型的值，且只能取给定的值之一。

set是一个字符串对象，必须是空字符串或以逗号分隔的值，一个set最多指定64个不同的值。

#### 触发器trigger

事先为一张表绑定一段代码，当表中一些内容发生改变(insert, delete, update)，系统自动触发这些代码并执行。

触发器的三要素：

1. 事件类型：insert, delete, update
2. 触发时间：before, after
3. 触发对象：整张表

每张表只能拥有一种触发时间的一种事件类型的触发器，因此最多拥有6个触发器。

[mysql触发器](https://blog.csdn.net/qq_35246620/article/details/78946070)

#### 视图

视图是一种虚拟的表，是作为一个select保存在数据字典中的。

视图的功能和物理的表相同。对视图的修改不影响基本表，起一个“安全层”的作用。

# 文件

数据库中的文件：

1. 参数文件：告诉MySQL实例启动时在哪里可以找到数据文件，并制定某些初始化参数，定义了某种内存结构的大小等设置。
2. 日志文件：记录MySQL实例对某种条件作出响应时写入的文件，例如：错误日志文件、二进制日志文件、慢查询日志文件、查询日志文件等。
3. socket文件：用unix域套接字方式连接时需要的文件。
4. pid文件：MySQL实例的进程ID文件。
5. MySQL表结构文件：存放MySQL表结构定义文件。
6. 存储引擎文件：对innoDB：有表空间文件、重做日志文件。
	- 表空间文件：innoDB采用了将存储的数据按表空间进行存放的设计。在默认配置下，有一个初始大小为10MB、名为ibdata1的文件，是默认的表空间文件。
	- 重做日志文件：默认情况下，innoDB存储引擎的数据目录下有ib_logfile0和ib_logfile1两个文件(redo log file)。它记录了对于innoDB存储引擎的事务日志。
		- 重做日志文件的主要目的：万一实例或介质失败，innoDB存储引擎要使用重做日志文件来恢复到掉电前的时刻，从而保证数据的完整性。
		- 每个innoDB存储引擎至少有一个重做日志文件组，每个组至少有2个大小相同的重做日志文件，多个文件已循环写入的方式运行。



# 数据库存储引擎

#### InnoDB的特性

1. 插入缓冲(insert buffer)
	- 对于非聚集索引来说，叶子节点的插入是无序的，因此就需要离散的访问非聚集索引页，降低了插入性能。
	- 对非聚集类索引的插入和更新操作，不是每次直接插入索引页，而是先插入到内存中。具体做法：如果该索引页在缓冲池中，直接插入；如果不在，现将其放在缓冲区中，再以一定频率和索引页合并，这时候就可以将同一个索引页中的多个插入合并到一个IO操作中，从而提高写性能。
	- 插入缓冲的启用需要满足下面的条件：
		- 索引是辅助索引
		- 索引不是唯一的。如果是唯一的，那么在插入时就需要查找辅助索引进行判断来确保唯一性，因此就没有意义了。
	- 产生的问题：
		- 导致数据库宕机后的恢复时间更长。一旦出现宕机，内存中会有大量数据没有合并到索引页中，从而导致实例的回复时间较长。
		- 插入缓冲在写密集的情况下会占用较多的缓冲池内存。
2. 二次写(doublewrite)
	- 在数据库正在从内存向磁盘写入一个数据页时，如果发生宕机，会导致该页只写了部分数据（部分写失效），导致数据丢失。这无法通过重做日志恢复。
	- 两次写的原理：
		- 当刷新缓冲池脏页时，并不直接写入数据文件中，而是先拷贝到内存中的两次写缓冲区(doublewrite buffer, 2MB)
		- 通过doublewritebuffer分两次，每次1MB顺序的写入磁盘共享表空间。
		- 将doublewrite buffer写入数据文件。
	- 这样由于磁盘共享表空间中已经有了数据页的副本，因此在实例恢复时可以从共享表空间中找到副本，将其拷贝覆盖原有的数据也，然后应用重做日志即可。第二部是额外的开销，但由于磁盘共享表空间是连续的，因此开销并不大。
3. 自适应哈希索引
	- 哈希索引查找的时间复杂度为常量，而B+树高度一般为3-4层。当InnoDB观察到建立哈希索引可以带来速度提升时，则建立哈希索引。因此称为自适应哈希索引(Adaptive Hash Index, AHI)。AHI通过缓冲池的B+树页构造，不需要对整个表建立哈希索引，因此速度很快。

#### InnoDB和myISAM的区别

1. InnoDB支持事务，myISAM不支持
2. InnoDB锁粒度是行级，myISAM锁粒度是表级
3. InnoDB支持数据库并发控制MVCC，myISAM不支持
4. InnoDB支持外键，myISAM不支持
5. InnoDB不支持全文索引，myISAM支持全文索引

myISAM管理非事务表，它能够提供高速存储和检索，并具有全文搜索能力。如果有大量的select查询，myISAM性能较好。

InnoDB用于事务处理应用程序。如果有大量的insert和update操作，应该使用InnoDB。

# delete drop truncate的区别

delete和truncate只删除数据，不删除表结构， drop删除表结构
速度上 drop > truncate > delete

- 不再需要表时drop
- 清空表用truncate
- 删除部分记录用delete

# 索引

#### 索引组织表

在InnoDB存储引擎中，表都是根据主键顺序组织存放的，这种存储方式称为索引组织表。

在InnoDB存储引擎表中，每张表都有一个主键，如果没有显示定义主键，InnoDB会按照下面的方法选择或创建主键：

- 判断表中有没有非空唯一索引，如果有，以其为主键(选择建表时定义的第一个唯一非空索引为主键)
- 如果没有，自动创建一个6字节大小的指针。

#### InnoDB存储支持的索引

1. B+树索引
2. 全文索引
3. 哈希索引

其中哈希索引是自适应的，不能人为干预。

myISAM和InnoDB的索引都采用B+树结构。B树和B+树的讲解：↓

[B树和B+树](https://www.cnblogs.com/nullzx/p/8729425.html)

B+树索引是目前最常用最有效的索引。B+树索引不能找到给定键值的具体行，只能找到被查询数据所在的页。数据库通过把页读入内存，在内存中进行查找，最后找到要查找的数据。

在数据库中，B+树的高度一般在2到4层。

数据库中的B+树索引可以分为聚集索引(clustered index)和辅助索引(secondary indel)。聚集索引和辅助索引的不同在于叶子节点存放的是否是一整行的信息。

#### 聚集索引

聚集索引是按照每张表的主键构建一棵B+树，同时叶子节点中存放的即是整张表的行记录数据，因此也将聚集索引的叶子节点称为数据项。这个特性决定了索引组织表中的数据也是索引的一部分。

每张表只能有一个聚集索引。多数情况下，由于聚集索引是有序的，并且能够在B+树索引的叶子节点上直接找到数据，查询优化器倾向于采用聚集索引。

聚集索引对逐渐的排序查找和范围查找效率非常高。

#### 辅助索引(非聚集索引)

辅助索引的叶子节点并不包含行记录的全部数据。叶子节点除了包含键值之外，每个叶子节点的索引行包含了一个书签，通过书签告诉InnoDB存储引擎可以在哪里找到与索引相对应的数据。

每张表上可以有多个辅助索引。通过辅助索引查找数据时，InnoDB存储引擎先遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，再通过主键索引找到一行完整的记录。

#### 联合索引

联合索引是指对表上的多列进行索引。

使用联合索引要遵循最左匹配原则

#### 覆盖索引

如果二级索引中包含了查询所需的数据，那么久不需要再去聚集索引中查找了。

覆盖索引指的是一个查询语句只需要从辅助索引中就能够取得要查询的记录，不需要查询聚集索引中的记录。好处是辅助索引不包含整行记录信息，因此其大小远小于聚集索引，可以减少大量的IO操作。

#### 优化器选择不使用索引的情况

对于不能使用覆盖索引的情况，优化其选择辅助索引的条件是：通过辅助索引查找的数据是少量的。因为顺序读的效率远高于随机读。

#### 哈希索引

InnoDB存储引擎使用哈希算法对字典进行查找，冲突解决机制采用链表方式，哈希函数采用除法散列。

哈希表的大小一般采用大于页数两倍的最小的质数。

#### 全文检索(Full-Text Searcn)

全文检索指将存储在数据库中的整本书或整篇文章的任意内容查找出来的技术。InnoDB从MySQL5.6开始支持全文索引。

$$
MATCN() ... AGAINST()
$$

MATCH指定要查询的列，AGAINST指定查询方法

MySQL有三种类型的全文检索：

1. 自然语言检索
	- 默认类型，查询带有指定word的文档。
	- 在where中使用match，查询结果是根据相关性排序的。相关性的计算条件：
		- word是否在文档中出现
		- word出现的次数
		- word在索引列中的数量
		- 多少个文档包含该word
2. 布尔检索
	- 使用一些特定意义的操作符，如+、-等
3. 查询扩展检索
	- 是自然语言检索的一个变种，当查询短语太短时有用，是在自然语言检索的基础上，将最相关行中的词添加到查询字符串中进行二次检索。

# 锁

#### 表级锁和行级锁：

- 表级锁：开销小，加锁快。不会出现死锁。锁粒度大，容易发生锁冲突，并发度低。
- 行级锁：开销大，加锁慢。会出现死锁。锁粒度小，发生锁冲突概率低，并发度高。

InnoDB支持行级锁。

#### lock与latch：

||lock|latch|
|---|---|---|
|对象|事务|线程|
|保护|数据库内容|内存数据结构|
|持续时间|整个事务过程|临界资源|
|模式|行锁、表锁、意向锁|读写锁、互斥量|
|死锁检测|有|无|
|存在位置|Lock Manager的哈希表中|每个数据结构的对象中|

#### 锁的类型

共享锁(S Lock):允许事务读一行数据

排它锁(X Lock):允许事务删除或更新一行数据

S和X都是行锁

意向锁(Intention Lock)： 将锁定的对象分为多个层次，意味着事务希望在更细粒度上进行加锁。

意向共享锁(IS Lock):事务想要获得一张表中几行的共享锁

意向排它锁(IX Lock):事务想要获得一张表中几行的排它锁

InnoDB的意向锁都是表锁。意向锁不会阻塞除全表扫描以外的任何请求。

表级意向锁与行级锁的兼容性：

||IS|IX|S|X|
|---|---|---|---|---|
|IS|兼容|兼容|兼容|不兼容|
|IX|兼容|兼容|不兼容|不兼容|
|S|兼容|不兼容|兼容|不兼容|
|X|不兼容|不兼容|不兼容|不兼容|

#### 一致性非锁定读

一致性非锁定读指InnoDB引擎通过多版本控制的方法来读取当前执行时间数据库中行的数据。当要读取的行有排它锁时，不用等待锁的释放，而是去读取快照数据。

快照数据的作用是在事务中回滚数据，因此没有额外开销。

一行记录可能不只有一个快照数据，这种技术称为行多版本技术。由此带来的并发控制称为多版本并发控制(Multi Version Concurrency Control, MVCC)。

在read committed隔离级别下，读取最新一份快照数据；在read repeatable隔离级别下，读取事务开始时的版本。

（对read committed事务隔离级别来说，违反了事务的隔离性）

#### 一致性锁定读

有的情况下，为了保证数据的逻辑一致性，需要对select操作进行加锁。InnoDB对select语句支持两种一致性锁定读操作：

- select ... for update，对读取的行记录加一个X锁
- select ... lock in shape mode，对读取的行记录加一个S锁，其他事务可以对其加S锁。

#### 行锁的三种算法

1. Record Lock:单个行记录上的锁。
	- 锁住的是索引记录而不是真正的数据记录
		- 如果是非主键索引，会在该索引上加锁后再去主键上加锁
		- 如果表上没有索引，会对隐藏的主键索引加锁
2. Gap Lock:间隙所，锁定一个范围，但不包含记录本身。
	- 不会阻塞其他的间隙锁，但会阻塞插入间隙锁，防止幻读
3. Next-Key Lock:上面二者的结合，锁定一个范围，包含记录本身。
	- 在默认隔离级别(RR)下，InnoDB都是采用这种锁定算法

#### 锁问题(脏读、不可重复读、幻读)

1. 脏读：一个事务访问了另一个事务未提交的数据，但另一个事物执行了回滚
2. 不可重复读：一个事务读取同一条记录2次，但读到的结果不一致
3. 幻读：一个事务读取了两次，读到的记录数不一致

#### 死锁

死锁指两个以上的事务在执行过程中，因为争夺资源导致的相互等待的现象。若无外力作用，则会永远等待下去。

解决方法：

- 超时
- 用等待图(wait-for graph)进行死锁检测(InnoDB的方式)

#### 锁升级

锁升级指将锁的粒度降低：行->页->表

InnoDB没有锁升级。

# MySQL备份与恢复

根据备份方法不同，可以分为：

- 热备份Hot Backup：数据库运行中直接备份
- 冷备份Cold Backup：数据库停止的情况下备份
- 温备份Warm Backup：在数据库运行中备份，但是会对当前数据库的操作有所影响

根据备份后文件的内容，可以分为：

- 逻辑备份：备份出的文件内容是可读的
- 裸文件备份：复制出数据库的物理文件

根据备份数据库的内容，可以分为：

- 完全备份
- 增量备份
- 日志备份

#### Mysqldump

Mysqldump属于逻辑备份、热备份。规模较小、业务不繁忙的数据库，一般选择Mysqldump。

#### Xtrabackup

Xtrabackup属于物理备份、热备份。

