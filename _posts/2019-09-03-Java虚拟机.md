---
layout:     post
title:      Java虚拟机
subtitle:   Java虚拟机
date:       2019-09-03
author:     正版慕言
header-img: img/blog_bg_1.jpg
catalog: true
mathjax: true
tags:
    - Java虚拟机

---

# Java内存管理

#### 运行时数据区域

1. 程序计数器：当前线程执行的字节码的行号指示器，是线程私有的。如果是native方法，指示器为空。
2. Java虚拟机栈：线程私有的，描述Java方法执行的内存模型
3. 本地方法栈：为虚拟机使用到的native方法服务
4. Java堆：存放对象实例
5. 方法区：各线程共享，存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等

6. 运行时常量池
7. 直接内存

#### 对象的创建过程：

1. 检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查引用的类是否已被加载、解析和初始化过。如果没有，要先执行相应的类加载过程。
2. 为新生对象分配内存。
- 如果Java堆内存是规整的，用“指针碰撞”(将分界点的指针向空闲区挪动待分配对象大小的距离)。(Serial、ParNew等)
- 如果Java堆内存不规整，用“空闲列表”，找到一个足够大的内存空间划分给它。(CMS等)
- 解决并发情况下的冲突：
	+对分配内存空间的动作进行同步处理
	+为每个线程预先分配一个TLAB(本地线程分配缓冲)
3. 对对象进行必要的设置：属于哪个类、哈希码、GC分代年龄等
4. 执行new后接着执行init方法，按照程序员的意愿进行初始化

# GC

判断对象已死：

1. 引用计数法：引用计数器
- 缺点：无法解决循环引用的问题
2. 可达性分析法：通过一系列的GC Roots 对象作为根开始向下搜索，搜索过的路径称为“引用链”。一个对象到GC Roots没有任何引用链，则对象已死
- GC Roots的对象包含：虚拟机栈中引用的对象、方法区中静态属性和常量引用的对象、本地方法栈中native方法引用的对象

强引用：new的引用
软引用：有用但非必须的对象，在溢出前会将其列入回收对象
弱引用：只能存活到下一次GC之前
虚引用：唯一的作用是在被回收时获得一个系统通知

**GC算法：**

1. 标记-清除算法
- 先标记出待回收对象，标记完成后统一回收。
- 不足：标记和回收的效率都不高，会产生不连续的内存碎片
2. 复制算法
- 将可用内存划分为相等两块，每次使用其中的一块。当需要回收时，将存活的对象复制到另一块，然后将该块一次性清理
- 代价：可用内存被缩小
3. 标记-整理算法
- 标记过程与1相同，但回首时是将存活的对象移动到内存区域的一端
4. 分代收集算法
- 将堆划分为新生代和老年代，新生代使用复制算法，老年代使用标记-清除或标记-整理算法

**垃圾收集器**

1. Serial收集器
- 单线程的收集器，只会使用1个CPU和一条线程，在GC时要STW。
- Serial的优点：简单高效，是client模式下新生代的默认收集器
2. ParNew收集器
- Serial收集器的多线程版本
- 是server模式下新生代的首选收集器(只有它能与CMS收集器配合工作)
3. Parallel Scavenge 收集器
- 其他GC关注缩短STW时间，Parallel Scavenge关注吞吐量(用户代码运行时间/(用户代码运行时间+垃圾收集时间))
- 两个参数：
	+MaxGCPauseMillis：最大GC停顿时间
	+GCTimeRatio：直接设置吞吐量大小
- 还有一个参数：UseAdaptiveSizePolicy：GC自适应的调节策略
4. Serial Old收集器
- Serial的老年代版本，使用标记-整理算法
5. Parallel Old收集器
- Parallel Scavenge的老年代版本，使用多线程和标记-整理算法
6. CMS收集器(Concurrent Mark Sweep)
- CMS收集器以获取最短STW为目标，基于标记-清除算法
- 步骤：
	+初始标记：需要STW，仅标记GC Roots直接关联的对象
	+并发标记：进行GC Roots Tracing
	+重新标记：需要STW，修正上一步骤期间用户程序继续运行导致的变动
	+并发清除：清理无效的对象
- 缺点：
	+对CPU资源敏感。在并发阶段，会因为占用一部分线程导致应用程序变慢。默认线程数：(CPU + 3) / 4
	+无法处理浮动垃圾：清理阶段产生的辣鸡无法在当次收集中处理掉
	+标记-清除算法会导致大量碎片空间的产生，给大对象的分配带来麻烦而提前出发Full GC
7. G1收集器
- G1是一款面向服务端应用程序的垃圾收集器
- 特点：
	+并行和并发：通过多核来缩短STW
	+分代收集
	+空间整合：能提供规整的可用内存
	+可预测停顿时间
- Region：G1的各代存储地址是不连续的，每一代都有n个不连续的大小相等的Region。(下图中标记H的表示存储的是大对象(大于等于region的一半，直接分配到老年代))
- 每个region都有一个remembered set,记录其他region中的对象引用本region中对象的关系。
- 收集：
	+初始标记：同CMS
	+并发标记：同CMS
	+最终标记：修正并发标记期间应用程序造成的变化，这些变化记录在线程remembered set logs里，最终标记要将其合并到remembered set里。需要停顿线程，但可并行执行。
	+筛选回收：先对各region的回收价值和成本进行排序，根据用户期望的GC停顿时间指定回收计划，可以与用户程序一起并发执行。

![G1内存布局](/img/Journal/G1内存布局.png)

**GC日志**
P89

**内存分配与回收**

1. 一般情况下，对象在Eden区分配。当Eden区满后，出发Minor GC
2. 大对象直接进入老年代
3. 长期存活的对象进入老年代(年龄计数器有4位，因此对象在经历15次GC并存活会进入老年代)
4. 动态对象年龄判定：不要那么僵，如果survivor空间中相同年龄的所有对象大小的总和超过survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。

# Class文件结构

Class文件是8位字节的二进制流文件。

Java源文件被编译之后每个类都有一个单独的class文件，且类中的所有信息都在class文件中有相应的描述。

class文件中的信息是按项排列的，每项有固定长度，不同长度分别用u1, u2, u4, u8表示(可以看做数据项的“类型”)。

class文件格式

|类型|名称|数量|
|---|---|---|
|u4|magic|1|
|u2|minor_version|1|
|u2|major_version|1|
|u2|constant_pool_count|1|
|cp_info|constant_pool|constant_pool_count - 1|
|u2|access_flags|1|
|u2|this_class|1|
|u2|super_class|1|
|u2|interfaces_count|1|
|u2|interfaces|interfaces_count|
|u2|fields_count|1|
|field_info|fields|fields_count|
|u2|methods_count|1|
|method_info|methods|methods_count|
|u2|attributes_count|1|
|attribute_info|attributes|attributes_count|

#### 魔数与文件版本

每个class文件的前4个字节称为魔数(magic number)，作用是确定这个文件是否为一个能被虚拟机接受的class文件。class文件的魔数是0xCAFEBABE(咖啡宝贝)。

紧接着魔数的4个字节是版本号，版本号的前2个字节是次版本号，后两个字节是主版本号。Java的版本号从45开始，从jdk1.1之后每个大版本其主版本号向上+1。版本向下兼容。

#### 常量池

版本号后面是常量池入口。常量池可以理解为class文件中的资源仓库，是与其他项目关联最多的数据类型，也是占用空间最大的项目之一。

常量池入口要设置一个u2类型的数据，代表容量计数器，这个计数器是从1开始的，其值为n时，代表有n-1项常量，编号为1到21。

第0项表示“不引用任何一个常量池项目”

常量池中有两大类常量：字面量和符号引用。

字面量即文本字符串、final常量值等

符号引用包含三类常量：
- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符

#### 访问标志

常量池后面是两字节的访问标志(access_flags)，用于识别一些类或者接口层次的访问信息(如：class是类还是接口，是否为public类型，是否为abstract类型，如果是类是否为final等)。

#### 类索引、父类索引与接口索引集合

类索引和父类索引是u2类型的数据，接口索引集合是一组u2类型的数据集合。他们确定该类的继承关系。

#### 字段表集合

字段表(field_info)描述接口或者类中声明的变量。

字段field包含类级和实例级变量，不包括方法内部的局部变量。

可以包括的信息有：
- 字段的作用域(public、private、protected修饰符)
- 是实例变量还是类变量(static修饰符)
- 可变性(final)
- 并发可见性(volatile)
- 是否可被序列化(transient)
- 字段数据类型(基本类型、对象、数组)
- 字段名称

各修饰符都是bool值，可以用标志位表示。字段名、字段数据类型引用常量池中的常量来描述。

#### 方法表集合

格式与字段表采用了几乎一样的格式

结构：
- 访问标志 access_flags
- 名称索引 name_index
- 描述符索引 descriptor_index
- 属性表集合 attributes

方法里的Java代码存放在方法属性表集合中一个名为Code的属性里。

#### 属性表集合

用于描述某些场景专有的信息。

P180

#### 字节码指令

Java虚拟机指令由一个字节长度的操作码及其0个至多个所需的参数构成。由于操作码长度只有1字节，因此最多只能有256条。

指令有加载和存储指令、运算指令、类型转换指令、对象创建与访问指令、操作数栈管理指令、控制转移指令、方法调用和转移指令、异常处理指令、同步指令等。

# 虚拟机类加载机制

虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机直接使用的Java类型，就是虚拟机的类加载机制。

Java类型的加载、连接和初始化是在程序运行期间完成的，虽然会损失一些性能，但提供了更高的灵活性。

#### 类加载的时机

一个类从加载到虚拟机内存到卸载的整个生命周期包括 加载、验证、准备、解析、初始化、使用、卸载 7个阶段。其中，验证、准备、解析三个部分统称为连接。

加载、验证、准备、初始化、卸载 这5个阶段的开始顺序是确定的，而解析阶段在某些情况下可以在初始化之后开始。

Java虚拟机规范规定有且只有5种情况必须立即对类进行初始化：

1. 遇到new、getstatic、putstatic、invokestatic这4个字节码指令时
2. 使用java.lang.reflect对类进行反射调用的时候
3. 初始化一个类时，如果父类还没有初始化，要对父类进行初始化
4. 虚拟机启动时，用户要指定一个主类进行初始化(包含main()方法的那个类)
5. 使用jdk1.7动态语言支持时，一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄对应的类如果没有初始化，要先触发初始化

#### 类加载的过程

1. 加載。
- 在加载阶段，虚拟机要完成三件事：
	+通过一个类的全限定名获取定义此类的二进制字节流
		+可以从zip包读取，是读取JAR、EAR、WAR格式的基础
		+可以从网络获取，典型应用是Applet
		+运行时计算生成(动态代理技术)
		+由其他文件生成(JSP)
		+从数据库读取
	+将这个字节流代表的静态存储结构转化为方法区的运行时数据结构
	+在内存中生成一个代表这个类的java.lang.Class对象，作为方法区中这个类的各种数据的访问入口
2. 验证。
- 验证是连接阶段的第一步，确保class文件字节流包含的信息符合当前虚拟机的要求且不会危害虚拟机自身的安全。
- 由于字节码文件并非必须由Java代码编译而来，因此虚拟机需要检查输入的字节流以确保安全。验证阶段决定了Java虚拟机是否能承受恶意代码的攻击。
- 验证阶段会完成4个阶段的检验动作：
	+文件格式验证(保证字节流符合class文件格式规范)
		+是否已魔数0xCAFEBABE开头
		+主次版本号
		+常量池是否有不支持的常量类型
		+指向常量的各种索引值是否合法
		+CONSTANT_Utf8_info型常量中是否有不符合utf8编码的数据
		+class文件中是否有被删除或附加的其他信息
	+元数据验证(保证符合Java语言规范)
		+该类是否有父类
		+父类是否继承了不允许被继承的类
		+如果不是抽象类，是否实现了要求实现的所有方法
		+类中的字段、方法是否和父类产生了矛盾等
	+字节码验证(最复杂的阶段，确定程序语义是合法的、符合逻辑的)
		+保证数据类型与指令能够配合工作
		+保证跳转指令不会跳转到方法体外
		+保证方法体中的类型转换是有效的
	+符号引用验证(确保解析动作能正常执行)
		+通过字符描述的全限定名是否能找到对应类
		+在指定类中是否存在复合方法的字段描述符以及简单名称所描述的方法和字段
		+符号引用中的类、字段、方法的方文熙是否可被当前类访问
3. 准备
- 为类变量分配内存并设置类变量初始值。
- 这时候进行内存分配的只有类变量(static)，不包括实例变量，且类变量尚未赋值。
4. 解析
- 虚拟机将常量池内的符号引用替换为直接引用的过程。
	+符号引用：以一组符号来描述引用的下标，可以使任何形式的字面量，只要使用时能无歧义的定位到目标即可。
	+直接引用：可以是直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄
5. 初始化
- 真正开始执行类中定义的Java程序代码
-根据程序员通过程序指定的主观计划来初始化类变量和其他资源

#### 类加载器

Java虚拟机将“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部实现，以便让应用程序自己决定如何获取所需要的类。实现这个动作的代码模块称为“类加载器”。最初是为了满足Applet需求而开发的。

1. 类与类加载器
- 任何一个类都需要由加载它的类加载器和它本身一同确立其在Java虚拟机中的唯一性。(比较两个类是否“相等”)。
2. 双亲委派模型
- 从Java虚拟机角度讲，类加载器有两种
	+启动类加载器，用C++实现，是虚拟机自身的一部分
	+其他所有的类加载器，用Java实现，独立于虚拟机外部，继承自java.lang.ClassLoader
- 从开发人员角度讲，可以分得更细。大多数Java程序用到以下三种：
	+启动类加载器：负责将<JAVA_HOME>\\lib中的类库加载到虚拟机中
	+扩展类加载器：将<JAVA_HOME>\\lib\\ext中的类库加载到虚拟机中
	+程序应用类加载器：将用户类路径上的指定类库
![双亲委派模型](/img/Journal/双亲委派模型.png)
- 双亲委派模型要求除了顶层的启动类加载器外，其余加载器都应该有自己的父类加载器。这里类加载器之间的父子关系一般不以继承关系实现，而是使用组合关系来复用父类加载器的代码。
- 如果一个类加载器收到了类加载的请求，它会把这个请求委派给父类加载器，每一层的类加载器都会如此，因此所有的加载请求最后都会进入顶层的启动类加载器。只有父类加载器反馈自己无法完成加载请求，子加载器才会尝试自己去加载。
3. 破坏双亲委派模型
- 双亲委派模型不是一个强制性约束模型。目前为止，双亲委派模型有3次较大的“被破坏”的情况。
	+双亲委派模型对JDK1.2之前还没有它的代码做了妥协，设置了protected方法findClass()以向前兼容。
	+自身缺陷导致：基础类又要调用回用户的代码。引入了线程上下文加载器。
	+用户对程序动态性的追求导致：用户希望应用程序能“即插即用”。

# 虚拟机字节码执行引擎

执行引擎是Java虚拟机最核心的组成部分之一。

物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，虚拟机的执行引擎是由自己实现的。

所有的Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。

#### 运行时栈帧结构

栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机栈的栈元素。它储存方法的局部变量表、操作数栈、动态链接和方法返回地址以及附加信息。

一个方法从调用开始到执行完成的过程都对应着一个栈帧从入栈到出栈的过程。

对执行引擎来说，在活动线程中，只有当前栈帧是有效的，所有字节码都只针对当前栈帧进行操作。

![栈帧的概念结构](/img/Journal/栈帧的概念结构.png)

1. 局部变量表
- 局部变量表是一组变量值存储空间，存放方法参数和方法内部定义的局部变量。在Java编译为class文件时，就确定了该方法需要分配的局部变量表的最大容量。
- 变量槽Slot：局部变量表的容量以slot为最小单位，每个变量槽可以存储32位长度的内存空间。
- 对64位的数据类型，虚拟机会高位对齐分配两个连续的slot。
2. 操作数栈
- 是一个后入先出(LIFO)的栈。和局部变量表一样，也是在编译时期就确定了最大深度。
- 操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。32位数据类型所占容量为1，64位为2。
- 方法开始执行时，栈空；过程中，字节码指令会向其中写入和提取内容，即入栈和出栈。
3. 动态链接
- 每个栈帧都包含一个指向运行时常量池中该栈帧所述方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。
4. 返回地址
- 一个方法开始执行后，有两种方式可以退出该方法：
	+方法返回指令：执行引擎遇到一个方法返回的字节码指令
	+异常退出：方法执行过程中遇到了异常，且没有处理这个异常
- 方法退出后，都需要返回到方法被调用的位置，程序才能继续执行。一般来说，正常退出时，调用者的PC计数器可以作为返回地址，一般保存在栈帧中；异常退出时，返回地址要通过异常处理器表来确定，栈帧中一般没有保存。
5. 附加信息
- 虚拟机规范允许增加一些规范里没有的描述信息。

#### 方法调用

方法调用的唯一任务是确定被调用的方法的版本，不涉及方法内部的具体运行过程。

1. 解析
- 在类加载的解析过程，会将class文件中一部分符号引用转化为直接引用。
调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析。
2. 分派
- 分派调用揭示多态性特征的一些最基本的体现
- 静态分派
	所有依赖静态类型而非实际类型来定位方法执行版本的分派动作称为静态分派。典型应用是方法重载。静态分配是在编译阶段发生的，因此确定静态分派的动作并不是由虚拟机来执行的。
- 动态分派
	动态分派最直接的例子是重写。涉及Java虚拟机的invokevirtual指令。invokevirtual指令的运行步骤：
	+找到操作数栈栈顶第一个元素指向的对象的实际类型，记作C
	+如果在C中找到相符的方法，则进行访问权限校验，通过则返回该方法的直接引用，否则返回非法访问异常
	+如果没有找到，则按照继承关系从下到上一次对C的各父类进行第二步的搜索和验证过程
	+如果最终没有找到，则抛出抽象方法错误的异常

# Java内存模型与线程

#### Java内存模型

Java虚拟机规范通过定义一种Java内存模型来屏蔽各种硬件和操作系统的内存访问差异，实现让Java程序在各平台都能达到一致的内存访问效果。

Java内存模型规定所有的变量都存储在主内存中，同时每条线程有自己的工作内存。工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程的所有操作要在工作内存上进行，且每条线程不能访问其他线程的工作内存，线程之间的信息交互要通过主内存来完成。

#### 内存间交互操作

Java内存模型定义了8种操作来完成一个变量从主内存拷贝到工作内存和从工作内存同步回主内存的工作。这些操作必须是原子的、不可再分的。

- lock(锁定)：作用于主内存的变量，标识为线程独占状态
- unlock(解锁)：作用于主内存的变量，将其从锁定状态释放
- read(读取)：作用于主内存的变量，将值传输到工作内存
- load(载入)：作用于工作内存的变量，把read到的值放入工作内存的变量副本
- use(使用)：作用于工作内存的变量，将一个变量值传递给执行引擎
- assign(赋值)：作用于工作内存的变量，把一个从执行引擎得到的值付给工作内存中的变量
- store(存储)：作用于工作内存的变量，把其中的一个变量值传输到主内存中
- write(写入)：作用于主内存的变量，把store的值放入主内存的变量中

在执行以上8种基本操作时必须满足的规则：

- read和load、store和write必须成对使用。lock和unlock也应该是成对出现的。
- 变量在工作内存的改变必须同步回主存
- 不能无原因的(未发生assign操作)将数据同步回主存
- 新变量只能在主存中产生
- 一个变量同一时刻只能有一个lock
- lock一个变量会清空工作内存中此变量的值，执行引擎使用这个变量前要重新执行load或assign来初始化
- 如果一个变量没有被lock，就不能unlock。也不能unlock一个被其他线程lock的变量
- unlock之前，必须先把该变量同步回主存

**对于volatile型变量的特殊规则**

一个变量被volatile修饰时，它具备两个特性：
- 保证此变量对所有线程的可见性
	-如果一个线程修改了它的值，其他线程是立即可见的。但由于Java里面的运算并非原子操作，所以volatile变量的运算在并发下仍然是不安全的。
- 禁止指令重排序的优化
	-普通的变量不能保证变量赋值的操作顺序和程序代码中的执行顺序一致(发生了指令重排序的优化)。volatile禁止了这种优化(赋值后增加了一个内存屏障“lock addl $0x0, (%esp)”，让重排序时后面的代码不能重排序到屏障前面)

它保证了新值能立即同步到主内存，以及每次使用前立刻从主内存刷新。

**对long和double型变量的特殊规则**

对64位的未声明为volatile的long和double变量，如果多个线程共享时同时对他们进行读取和修改操作，可能会读到“半个变量”。

虽然Java内存模型不要求把long和double读写实现为原子操作，但虚拟机几乎都把它们作为原子操作对待。因此不用专门声明为volatile。

**原子性、可见性和有序性**

Java内存模型直接保证了read、load、assign、use、store和write的原子性。如果需要更大范围的保证原子性，可以使用lock和unlock，反映到java代码中就是synchronized。

可见性只当一个线程修改的共享变量的值，其它变量能立即得知。volatile变量的特殊规则保证了新值能立即同步回主内存及每次使用前从主内存刷新，从而保证了可见性。

有序性：Java语言提供了volatile和synchronized来保证线程之间操作的有序性。

**先行发生原则**

它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则我们可以通过几条规则来解决并发环境下两个操作之间是否可能存在冲突的所有问题。

先行发生是Java内存模型中定义的两项操作之间的偏序关系。如果A先行发生于操作B，操作A产生的影响能被操作B观察到。“影响”包括修改了共享变量的值、发送了消息、调用了方法等。

#### 线程

**线程实现的三种方式**

1. 使用内核线程实现：一般不是直接使用，而是使用它的高级接口————轻量级进程。每个轻量级进程要消耗一定的内核资源，因此一个系统支持的轻量级进程有限。
2. 使用用户线程实现：可以支持规模较大的线程数量，不需要系统内核支持，劣势也是没有系统内核的支持。
3. 使用用户线程加轻量级进程混合实现：操作系统提供支持的轻量级进程可以作为用户线程和内核线程之间的桥梁。

**Java的线程调度**

线程调度指系统为线程分配处理器使用权的过程。主要调度方式有两种：

1. 协同式线程调度：线程执行时间由线程自身控制，执行完毕后主动通知系统切换线程
- 好处：实现简单，没有线程同步问题
- 坏处：线程执行时间不可控，如果线程不告知系统进行切换，就会一直阻塞
2. 抢占式线程调度：由系统来分配执行时间。在Java中，Thread.yield()可以让出执行时间，但线程自身无法获取执行时间。

**线程的状态**

Java语言定义了5种线程状态，在任一时间一个线程有且只有一种状态。

- 新建(New)：创建后尚未启动
- 运行(Runnable)：正在执行或等待CPU分配执行时间
- 等待(Waiting)：
	+无限等待(Waiting)：等待被其他线程显式的唤醒
	+期限等待(Timed Waiting)：一定时间后由系统自动唤醒
- 阻塞(Blocked)：被阻塞。
- 结束(Terminated)：已终止

# 线程安全和锁优化

线程安全：当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。

#### Java的线程安全

按照线程安全的“安全程度”由强到弱进行排序，可以将Java语言中各种操作共享的数据分为5类:

1. 不可变：不可变的对象是绝对安全的。(final)
2. 绝对线程安全：完全满足上面关于线程安全的定义
3. 相对线程安全：是我们通常意义上说的线程安全，Java中大部分的线程安全类都属于这种类型。它保证对这个对象单独的操作是线程安全的，但对于一些特定顺序的连续调用，要使用额外的同步手段来保证调用的正确性。(Vector, HashTable等)
4. 线程兼容：对象本身不是线程安全的，但可以通过在调用端正确使用同步手段来保证对象在并发环境中可以安全使用。(ArrayList, HashMap等)
5. 线程对立：指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。(Thread类的suspend()和resume()方法)

#### 线程安全的实现方法

1. 互斥同步(Mutual Exclusion & Synchronization)
- 互斥同步是常见的一种并发正确性保障手段。同步指再多个线程并发访问数据时，保证共享数据在同时刻只被一个线程使用(在使用信号量时可以是一些)。互斥是实现线程同步的一种手段，方式有临界区、互斥量和信号量等。
- 在Java中，最基本的互斥同步手段是synchronized锁(monitorenter和monitorexit)。
- 除了synchronized外，可以使用JUC的重入锁ReentrantLock。ReentrantLock增加了一些高级功能：
	+ 等待可中断：当持有锁的线程长时间不释放锁时，等待线程可以选择放弃等待去处理其他事。
	+ 公平锁：多个线程在等待同一个锁时，要按照申请锁的时间顺序依次获得锁。synchronized是非公平锁，在锁被释放时任意一个等待线程都有机会获得锁，ReentrantLock默认也是非公平锁，但可以用带布尔值的构造函数要求使用公平锁。
	+ 锁绑定多个条件：一个ReentrantLock对象可以同时绑定多个Condition对象。
- 互斥同步属于一种悲观的策略
2. 非阻塞同步
- 非阻塞同步最主要的问题是进行线程阻塞和唤醒带来的性能问题，因此这种同步也称为阻塞同步。
- 非阻塞同步是一种乐观的策略，它先进行操作，如果没有其他线程争夺共享数据，则操作成功；如果有，产生了冲突，就采取其他的补偿措施(操作和冲突检测这两个步骤要具备原子性)。
3. 无同步方案
- 如果有一些代码天生就是线程安全的，就不需要同步措施。
	+ 可重入代码：也叫纯代码，可以在代码执行的任意时刻中断去执行另一段代码，控制权返回后代码不会出现任何错误。
	+ 线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，如果这些共享数据的代码能保证在同一个线程中执行，就可以把数据的可见范围控制在一个线程内，从而无需同步。

#### 锁

乐观锁：认为遇到并发写的可能性低(读多写少)，每次访问数据默认不会修改，所以不会上锁，但在更新时会判断在此期间有没有其他线程更新过这个数据。如果被更新过，则要重复CAS操作。

悲观锁：认为遇到并发写的可能性高(读少写多)，在读写数据时都会上锁。例如Java中的synchronized和ReentrantLock。

CAS：Compare and Swap，就是将内存值更新为需要的值，但要求必须与期望值相同。CAS指令需要有3个操作数：内存位置V、旧的预期值A、新值B。当且仅当V符合旧的预期值A时，用B更新V的值。无论是否更新了V的值，都会返回V的旧值。CAS是一个原子操作。

1. 自旋锁和自适应自旋
- 如果物理机上有一个以上的处理器能让两个或以上的线程同时执行，那么久可以让后面请求锁的线程执行一个忙循环(自旋)，稍等一等而不放弃处理器的执行时间，看持有锁的线程是否很快就会释放锁。这就是自旋锁。
- 如果锁占用时间很短，自旋锁的效果会很好。反之，则会白白消耗处理器资源。因此，自旋锁的时间要有一个限度(默认是10次，在jdk1.6之后变成了自适应的)。
2. 锁消除
- 指虚拟机即时编译器在运行时，对一些代码上要求同步但检测到不存在共享数据竞争的锁进行消除。
3. 锁粗化
- 原则上，推荐将同步块的范围限制的尽量小。但一些特殊情况下如果一系列连续操作对同一个对象频繁加锁解锁，那么即使没有线程竞争，频繁的互斥同步也会导致性能损耗。
- 如果虚拟机探测到这种情况，会将加锁同步的范围扩大到整个操作序列的外部。
4. 轻量级锁
- “轻量级”是相对使用操作系统互斥量来实现的传统锁而言的。传统的锁机制称为“重量级锁”。
- 轻量级锁的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”。如果没有竞争，则使用CAS操作避免了使用互斥量的开销；如果存在竞争，则除了互斥量还额外发生了CAS操作，因此性能会比重量级锁更慢。
- 轻量级锁的加锁操作：
	+ 代码进入同步块时，如果该同步对象没有被锁定，虚拟机首先将在当前线程栈帧中建立一个名为锁记录(Lock Record)的空间，存放锁对象目前的Mark Word拷贝(Mark Word是HotSport对象的对象头存放自身运行数据(HashCode、GC分带年龄等)的部分)。
	+ 虚拟机将使用CAS操作尝试将对象的MarkWord更新为指向Lock Record的指针。如果成功了，那么这个线程就获得了锁，且对象MarkWord的锁标志位(最后2bit)变为“00”表示对象处于轻量级锁锁定状态。如果失败了，虚拟机首先检查对象的MarkWord是否指向当前线程的栈帧，如果是说明当前线程已经拥有了锁，否则说明对象已被其他线程抢占。
	+ 如果有两条以上的线程争夺同一个锁，那么轻量级锁就要膨胀为重量级锁，标志位变成“10”。MarkWord中存储的就是指向重量级锁(互斥量)的指针，后面等待锁的线程进入阻塞状态。
- 轻量级锁的解锁操作：
	+ 如果对象的MarkWord仍然指向线程的锁记录，就用CAS操作把对象当前的MarkWord和线程中复制的Displaced Mark Word替换回来。如果替换成功，整个同步过程就完成了。如果失败，说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。
5. 偏向锁
- 目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。“偏”指这个锁会偏向于第一个获得它的线程。如果接下来的执行过程中该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。
- 原理：当锁对象第一次被线程获取，会将对象头中的锁标志位置为“01”(偏向模式)，同时通过CAS将线程ID记录在锁对象的MarkWord中。如果CAS成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时都不用再进行任何同步操作。但当另一个线程尝试去获得该锁时，偏向模式就结束了。要根据对象目前是否被锁定，撤销偏向后恢复到未锁定或升级到轻量级锁状态。