---
layout:     post
title:      Java虚拟机
subtitle:   Java虚拟机
date:       2019-09-03
author:     正版慕言
header-img: img/blog_bg_1.jpg
catalog: true
mathjax: true
tags:
    - Java虚拟机

---

# Java内存管理

#### 运行时数据区域

1. 程序计数器：当前线程执行的字节码的行号指示器，是线程私有的。如果是native方法，指示器为空。
2. Java虚拟机栈：线程私有的，描述Java方法执行的内存模型
3. 本地方法栈：为虚拟机使用到的native方法服务
4. Java堆：存放对象实例
5. 方法区：各线程共享，存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等

6. 运行时常量池
7. 直接内存

#### 对象的创建过程：

1. 检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查引用的类是否已被加载、解析和初始化过。如果没有，要先执行相应的类加载过程。
2. 为新生对象分配内存。
- 如果Java堆内存是规整的，用“指针碰撞”(将分界点的指针向空闲区挪动待分配对象大小的距离)。(Serial、ParNew等)
- 如果Java堆内存不规整，用“空闲列表”，找到一个足够大的内存空间划分给它。(CMS等)
- 解决并发情况下的冲突：
	- 对分配内存空间的动作进行同步处理
	- 为每个线程预先分配一个TLAB(本地线程分配缓冲)
3. 对对象进行必要的设置：属于哪个类、哈希码、GC分代年龄等
4. 执行new后接着执行init方法，按照程序员的意愿进行初始化

# GC

判断对象已死：

1. 引用计数法：引用计数器
- 缺点：无法解决循环引用的问题
2. 可达性分析法：通过一系列的GC Roots 对象作为根开始向下搜索，搜索过的路径称为“引用链”。一个对象到GC Roots没有任何引用链，则对象已死
- GC Roots的对象包含：虚拟机栈中引用的对象、方法区中静态属性和常量引用的对象、本地方法栈中native方法引用的对象

强引用：new的引用
软引用：有用但非必须的对象，在溢出前会将其列入回收对象
弱引用：只能存活到下一次GC之前
虚引用：唯一的作用是在被回收时获得一个系统通知

**GC算法：**

1. 标记-清除算法
- 先标记出待回收对象，标记完成后统一回收。
- 不足：标记和回收的效率都不高，会产生不连续的内存碎片
2. 复制算法
- 将可用内存划分为相等两块，每次使用其中的一块。当需要回收时，将存活的对象复制到另一块，然后将该块一次性清理
- 代价：可用内存被缩小
3. 标记-整理算法
- 标记过程与1相同，但回首时是将存活的对象移动到内存区域的一端
4. 分代收集算法
- 将堆划分为新生代和老年代，新生代使用复制算法，老年代使用标记-清除或标记-整理算法

**垃圾收集器**

1. Serial收集器
- 单线程的收集器，只会使用1个CPU和一条线程，在GC时要STW。
- Serial的优点：简单高效，是client模式下新生代的默认收集器
2. ParNew收集器
- Serial收集器的多线程版本
- 是server模式下新生代的首选收集器(只有它能与CMS收集器配合工作)
3. Parallel Scavenge 收集器
- 其他GC关注缩短STW时间，Parallel Scavenge关注吞吐量(用户代码运行时间/(用户代码运行时间+垃圾收集时间))
- 两个参数：
	- MaxGCPauseMillis：最大GC停顿时间
	- GCTimeRatio：直接设置吞吐量大小
- 还有一个参数：UseAdaptiveSizePolicy：GC自适应的调节策略
4. Serial Old收集器
- Serial的老年代版本，使用标记-整理算法
5. Parallel Old收集器
- Parallel Scavenge的老年代版本，使用多线程和标记-整理算法
6. CMS收集器(Concurrent Mark Sweep)
- CMS收集器以获取最短STW为目标，基于标记-清除算法
- 步骤：
	- 初始标记：需要STW，仅标记GC Roots直接关联的对象
	- 并发标记：进行GC Roots Tracing
	- 重新标记：需要STW，修正上一步骤期间用户程序继续运行导致的变动
	- 并发清除：清理无效的对象
- 缺点：
	- 对CPU资源敏感。在并发阶段，会因为占用一部分线程导致应用程序变慢。默认线程数：(CPU + 3) / 4
	- 无法处理浮动垃圾：清理阶段产生的辣鸡无法在当次收集中处理掉
	- 标记-清除算法会导致大量碎片空间的产生，给大对象的分配带来麻烦而提前出发Full GC
7. G1收集器
- G1是一款面向服务端应用程序的垃圾收集器
- 特点：
	- 并行和并发：通过多核来缩短STW
	- 分代收集
	- 空间整合：能提供规整的可用内存
	- 可预测停顿时间
- Region：G1的各代存储地址是不连续的，每一代都有n个不连续的大小相等的Region。(下图中标记H的表示存储的是大对象(大于等于region的一半，直接分配到老年代))
- 每个region都有一个remembered set,记录其他region中的对象引用本region中对象的关系。
- 收集：
	- 初始标记：同CMS
	- 并发标记：同CMS
	- 最终标记：修正并发标记期间应用程序造成的变化，这些变化记录在线程remembered set logs里，最终标记要将其合并到remembered set里。需要停顿线程，但可并行执行。
	- 筛选回收：先对各region的回收价值和成本进行排序，根据用户期望的GC停顿时间指定回收计划，可以与用户程序一起并发执行。

![G1内存布局](/img/Journal/G1内存布局.png)

**GC日志**
P89

**内存分配与回收**

1. 一般情况下，对象在Eden区分配。当Eden区满后，出发Minor GC
2. 大对象直接进入老年代
3. 长期存活的对象进入老年代(年龄计数器有4位，因此对象在经历15次GC并存活会进入老年代)
4. 动态对象年龄判定：不要那么僵，如果survivor空间中相同年龄的所有对象大小的总和超过survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。

# Class文件结构

Class文件是8位字节的二进制流文件。

Java源文件被编译之后每个类都有一个单独的class文件，且类中的所有信息都在class文件中有相应的描述。

class文件中的信息是按项排列的，每项有固定长度，不同长度分别用u1, u2, u4, u8表示(可以看做数据项的“类型”)。

class文件格式

|类型|名称|数量|
|---|---|---|
|u4|magic|1|
|u2|minor_version|1|
|u2|major_version|1|
|u2|constant_pool_count|1|
|cp_info|constant_pool|constant_pool_count - 1|
|u2|access_flags|1|
|u2|this_class|1|
|u2|super_class|1|
|u2|interfaces_count|1|
|u2|interfaces|interfaces_count|
|u2|fields_count|1|
|field_info|fields|fields_count|
|u2|methods_count|1|
|method_info|methods|methods_count|
|u2|attributes_count|1|
|attribute_info|attributes|attributes_count|

#### 魔数与文件版本

每个class文件的前4个字节称为魔数(magic number)，作用是确定这个文件是否为一个能被虚拟机接受的class文件。class文件的魔数是0xCAFEBABE(咖啡宝贝)。

紧接着魔数的4个字节是版本号，版本号的前2个字节是次版本号，后两个字节是主版本号。Java的版本号从45开始，从jdk1.1之后每个大版本其主版本号向上+1。版本向下兼容。

#### 常量池

版本号后面是常量池入口。常量池可以理解为class文件中的资源仓库，是与其他项目关联最多的数据类型，也是占用空间最大的项目之一。

常量池入口要设置一个u2类型的数据，代表容量计数器，这个计数器是从1开始的，其值为n时，代表有n-1项常量，编号为1到21。

第0项表示“不引用任何一个常量池项目”

常量池中有两大类常量：字面量和符号引用。

字面量即文本字符串、final常量值等

符号引用包含三类常量：
- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符

#### 访问标志

常量池后面是两字节的访问标志(access_flags)，用于识别一些类或者接口层次的访问信息(如：class是类还是接口，是否为public类型，是否为abstract类型，如果是类是否为final等)。

#### 类索引、父类索引与接口索引集合

类索引和父类索引是u2类型的数据，接口索引集合是一组u2类型的数据集合。他们确定该类的继承关系。

#### 字段表集合

字段表(field_info)描述接口或者类中声明的变量。

字段field包含类级和实例级变量，不包括方法内部的局部变量。

可以包括的信息有：
- 字段的作用域(public、private、protected修饰符)
- 是实例变量还是类变量(static修饰符)
- 可变性(final)
- 并发可见性(volatile)
- 是否可被序列化(transient)
- 字段数据类型(基本类型、对象、数组)
- 字段名称

各修饰符都是bool值，可以用标志位表示。字段名、字段数据类型引用常量池中的常量来描述。

#### 方法表集合

格式与字段表采用了几乎一样的格式

结构：
- 访问标志 access_flags
- 名称索引 name_index
- 描述符索引 descriptor_index
- 属性表集合 attributes

方法里的Java代码存放在方法属性表集合中一个名为Code的属性里。

#### 属性表集合

用于描述某些场景专有的信息。

P180

#### 字节码指令

Java虚拟机指令由一个字节长度的操作码及其0个至多个所需的参数构成。由于操作码长度只有1字节，因此最多只能有256条。

指令有加载和存储指令、运算指令、类型转换指令、对象创建与访问指令、操作数栈管理指令、控制转移指令、方法调用和转移指令、异常处理指令、同步指令等。

# 虚拟机类加载机制

虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机直接使用的Java类型，就是虚拟机的类加载机制。

Java类型的加载、连接和初始化是在程序运行期间完成的，虽然会损失一些性能，但提供了更高的灵活性。

#### 类加载的时机

一个类从加载到虚拟机内存到卸载的整个生命周期包括 加载、验证、准备、解析、初始化、使用、卸载 7个阶段。其中，验证、准备、解析三个部分统称为连接。

加载、验证、准备、初始化、卸载 这5个阶段的开始顺序是确定的，而解析阶段在某些情况下可以在初始化之后开始。

Java虚拟机规范规定有且只有5种情况必须立即对类进行初始化：

1. 遇到new、getstatic、putstatic、invokestatic这4个字节码指令时
2. 使用java.lang.reflect对类进行反射调用的时候
3. 初始化一个类时，如果父类还没有初始化，要对父类进行初始化
4. 虚拟机启动时，用户要指定一个主类进行初始化(包含main()方法的那个类)
5. 使用jdk1.7动态语言支持时，一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄对应的类如果没有初始化，要先触发初始化

#### 类加载的过程

1. 加載

在加载阶段，虚拟机要完成三件事：
- 通过一个类的全限定名获取定义此类的二进制字节流
	- 可以从zip包读取，是读取JAR、EAR、WAR格式的基础
	- 可以从网络获取，典型应用是Applet
	- 运行时计算生成(动态代理技术)
	- 由其他文件生成(JSP)
	- 从数据库读取
- 将这个字节流代表的静态存储结构转化为方法区的运行时数据结构
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区中这个类的各种数据的访问入口

2. 验证

验证是连接阶段的第一步，确保class文件字节流包含的信息符合当前虚拟机的要求且不会危害虚拟机自身的安全。

由于字节码文件并非必须由Java代码编译而来，因此虚拟机需要检查输入的字节流以确保安全。验证阶段决定了Java虚拟机是否能承受恶意代码的攻击。

验证阶段会完成4个阶段的检验动作：
- 文件格式验证(保证字节流符合class文件格式规范)
	- 是否已魔数0xCAFEBABE开头
	- 主次版本号
	- 常量池是否有不支持的常量类型
	- 指向常量的各种索引值是否合法
	- CONSTANT_Utf8_info型常量中是否有不符合utf8编码的数据
	- class文件中是否有被删除或附加的其他信息
- 元数据验证(保证符合Java语言规范)
	- 该类是否有父类
	- 父类是否继承了不允许被继承的类
	- 如果不是抽象类，是否实现了要求实现的所有方法
	- 类中的字段、方法是否和父类产生了矛盾等
- 字节码验证(最复杂的阶段，确定程序语义是合法的、符合逻辑的)
	- 保证数据类型与指令能够配合工作
	- 保证跳转指令不会跳转到方法体外
	- 保证方法体中的类型转换是有效的
- 符号引用验证(确保解析动作能正常执行)
	- 通过字符描述的全限定名是否能找到对应类
	- 在指定类中是否存在复合方法的字段描述符以及简单名称所描述的方法和字段
	- 符号引用中的类、字段、方法的方文熙是否可被当前类访问

3. 准备

为类变量分配内存并设置类变量初始值。
这时候进行内存分配的只有类变量(static)，不包括实例变量，且类变量尚未赋值。

4. 解析

虚拟机将常量池内的符号引用替换为直接引用的过程。

- 符号引用：以一组符号来描述引用的下标，可以使任何形式的字面量，只要使用时能无歧义的定位到目标即可。
- 直接引用：可以是直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄

5. 初始化

真正开始执行类中定义的Java程序代码

根据程序员通过程序指定的主观计划来初始化类变量和其他资源

#### 类加载器

Java虚拟机将“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部实现，以便让应用程序自己决定如何获取所需要的类。实现这个动作的代码模块称为“类加载器”。最初是为了满足Applet需求而开发的。

1. 类与类加载器

任何一个类都需要由加载它的类加载器和它本身一同确立其在Java虚拟机中的唯一性。(比较两个类是否“相等”)。

2. 双亲委派模型

从Java虚拟机角度讲，类加载器有两种
- 启动类加载器，用C++实现，是虚拟机自身的一部分
- 其他所有的类加载器，用Java实现，独立于虚拟机外部，继承自java.lang.ClassLoader

从开发人员角度讲，可以分得更细。大多数Java程序用到以下三种：
- 启动类加载器：负责将<JAVA_HOME>\\lib中的类库加载到虚拟机中
- 扩展类加载器：将<JAVA_HOME>\\lib\\ext中的类库加载到虚拟机中
- 程序应用类加载器：将用户类路径上的指定类库

![双亲委派模型](/img/Journal/双亲委派模型.png)

双亲委派模型要求除了顶层的启动类加载器外，其余加载器都应该有自己的父类加载器。这里类加载器之间的父子关系一般不以继承关系实现，而是使用组合关系来复用父类加载器的代码。

如果一个类加载器收到了类加载的请求，它会把这个请求委派给父类加载器，每一层的类加载器都会如此，因此所有的加载请求最后都会进入顶层的启动类加载器。只有父类加载器反馈自己无法完成加载请求，子加载器才会尝试自己去加载。

3. 破坏双亲委派模型

双亲委派模型不是一个强制性约束模型。目前为止，双亲委派模型有3次较大的“被破坏”的情况。

- 双亲委派模型对JDK1.2之前还没有它的代码做了妥协，设置了protected方法findClass()以向前兼容。
- 自身缺陷导致：基础类又要调用回用户的代码。引入了线程上下文加载器。
- 用户对程序动态性的追求导致：用户希望应用程序能“即插即用”。


# 虚拟机字节码执行引擎

执行引擎是Java虚拟机最核心的组成部分之一。

物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，虚拟机的执行引擎是由自己实现的。

所有的Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。

#### 运行时栈帧结构

栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机栈的栈元素。它储存方法的局部变量表、操作数栈、动态链接和方法返回地址以及附加信息。

一个方法从调用开始到执行完成的过程都对应着一个栈帧从入栈到出栈的过程。

对执行引擎来说，在活动线程中，只有当前栈帧是有效的，所有字节码都只针对当前栈帧进行操作。

![栈帧的概念结构](/img/Journal/栈帧的概念结构.png)

1. 局部变量表

局部变量表是一组变量值存储空间，存放方法参数和方法内部定义的局部变量。在Java编译为class文件时，就确定了该方法需要分配的局部变量表的最大容量。

变量槽Slot：局部变量表的容量以slot为最小单位，每个变量槽可以存储32位长度的内存空间。
对64位的数据类型，虚拟机会高位对齐分配两个连续的slot。

2. 操作数栈

是一个后入先出(LIFO)的栈。和局部变量表一样，也是在编译时期就确定了最大深度。

操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。32位数据类型所占容量为1，64位为2。

方法开始执行时，栈空；过程中，字节码指令会向其中写入和提取内容，即入栈和出栈。

3. 动态链接

每个栈帧都包含一个指向运行时常量池中该栈帧所述方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。

4. 返回地址

一个方法开始执行后，有两种方式可以退出该方法：
- 方法返回指令：执行引擎遇到一个方法返回的字节码指令
- 异常退出：方法执行过程中遇到了异常，且没有处理这个异常

方法退出后，都需要返回到方法被调用的位置，程序才能继续执行。一般来说，正常退出时，调用者的PC计数器可以作为返回地址，一般保存在栈帧中；异常退出时，返回地址要通过异常处理器表来确定，栈帧中一般没有保存。

5. 附加信息

虚拟机规范允许增加一些规范里没有的描述信息。

#### 方法调用

方法调用的唯一任务是确定被调用的方法的版本，不涉及方法内部的具体运行过程。

1. 解析



2. 分派



#### 基于栈的字节码解释执行引擎

