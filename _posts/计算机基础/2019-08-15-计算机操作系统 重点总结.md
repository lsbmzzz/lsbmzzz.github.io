---
layout:     post
title:      计算机操作系统 重点总结
subtitle:   计算机操作系统 重点总结
date:       2019-08-15
author:     正版慕言
header-img: img/blog_bg_5.jpg
catalog: true
tags:
    - 操作系统

---

## 操作系统的四个特性

* 并发：同一时间内多个程序执行（并发和并行的区别：并行是同一时刻多个事件，并发是同一时间段内的多个事件）
* 共享：系统中的资源可以被内存中多个并发执行的进程线程共同使用
* 虚拟：通过分时复用以及空分复用技术将一个物理实体虚拟为多个
* 异步：系统中的进程是走走停停的方式运行的，并且速度不可预知

## 操作系统的主要功能

* 处理机管理：处理机分配以进程为单位，也可以看做进程管理。包括进程控制、进程同步、进程通信和进程调度
* 存储器管理：（内存管理），内存分配、内存保护、地址映射、虚拟内存
* 设备管理：管理外围设备
* 文件管理：管理用户文件和系统文件，方便使用同时保证安全性
* 提供用户接口：程序接口和用户接口

## 进程的几种状态、状态转换图和导致转换的事件
进程的基本状态有就绪、执行、阻塞：
![6b7487dcc92d189fb6b6a623d00adb09.png](/img/计算机基础/计算机操作系统-进程状态转换.png)

就绪状态：进程处于准备运行的状态，只要得到处理机即可运行
执行状态：正在处理机上运行
阻塞状态：进程正在等待某一事件

引入挂起和激活后：
![021ff731949d2d638b11177e26cc1a6f.png](/img/计算机基础/计算机操作系统-引入挂起的进程状态转换.png)

## 进程与线程的区别
进程是进程实体的运行过程，系统进行资源分配和调度的一个独立单位。引入进程是为了使多个程序可以并发执行，提高系统资源利用率和吞吐量。
线程是系统中可独立运行的基本单位。引入目的是减少程序在并发执行过程中的开销，提高系统并发效率。

对比：

* 调度方面：线程是独立地调度和分派单位，进程作为资源的拥有单位。
* 并发性：进程间可以并发，一个进程内部的多个线程也是可以并发的，进一步提高系统的资源利用率和吞吐量。
* 拥有资源：进程是基本的资源拥有单位，线程只拥有维持运行的很少的基本资源，可以访问所属的进程的资源。
* 系统开销：进程的创建和撤销需要系统创建或回收PCB和系统资源等，切换时也需要保存和恢复CPU环境。线程切换只需要保存和恢复少量寄存器，开销小。

## 进程通信的几种方式
进程通信指进程之间的信息交换。
高级通信方式有三类：

* 共享存储：进程之间存在一块可直接访问的共享空间。对共享空间的操作需要使用互斥工具。
* 消息传递：进程间的通信是以消息为单位。进程通过系统提供的发送消息和接收消息两个原语进行数据交换
    * 直接通信方式：发送进程直接把消息发送给接收进程
    * 间接通信方式：发送进程把消息发给某个中间实体，接收进程从中间实体取得消息。（信箱通信方式）
* 管道通信：消息传递的一种特殊方式。“管道”指用于链接一个读进程和一个写进程以实现通信的共享文件（pipe文件）。管道机制必须提供三个方面的协调能力：互斥、同步、确定对方的存在

## 进程同步的几种方式（重点）
同步机制要遵循的原则：

* 空闲让进：无进程在临界区时，要许可其他进程进入临界区
* 忙则等待：有进程在临界区时，其他进程要等待
* 有限等待：要保证进程在有限时间内可进入临界区
* 让权等待：进程无法进入临界区时，要释放处理机以免忙等

经典的进程同步问题：

* 生产者-消费者问题
* 哲学家进餐问题
* 读写者问题

```java
//生产者消费者问题Java实现
//生产者和消费者在同一时间段共用一个存储空间，生产者添加商品，消费者取出商品。空间空时，消费者阻塞；空面满时，生产者阻塞。
//来自w3cschool的实例：
public class Main {
      public static void main(String[] args) {
           // TODO Auto-generated method stub
           CubbyHole c = new CubbyHole();
           Producer p1 = new Producer(c, 1);
           Consumer c1 = new Consumer(c, 1);
           p1.start();
           c1.start();
     }
}

class CubbyHole{
     private int contents;
     private boolean available = false;
     public synchronized int get(){
           while(available == false){
                try{
                     wait();
                }catch(InterruptedException e){
                }
           }
           available = false;
           notifyAll();
           return contents;
     }
     public synchronized void put(int value){
           while(available == true){
                try{
                     wait();
                }catch(InterruptedException e){
                }
           }
           contents = value;
           available = true;
           notifyAll();
     }
}

class Consumer extends Thread{
     private CubbyHole cubbyhole;
     private int number;
     public Consumer(CubbyHole c, int number){
           cubbyhole = c;
           this.number = number;
     }
     public void run(){
           int value = 0;
           for(int i = 0; i < 10; i++){
                value = cubbyhole.get();
                System.out.println("消费者：" + this.number + " got:" + value);
           }
     }
}

class Producer extends Thread{
     private CubbyHole cubbyhole;
     private int number;
     public Producer(CubbyHole c, int number){
           cubbyhole = c;
           this.number = number;
     }
     public void run(){
           for(int i = 0; i < 10; i++){
                cubbyhole.put(i);
                System.out.println("生产者：" + this.number + " put:" + i);
                try{
                     sleep((int)(Math.random()*100));
                }catch(InterruptedException e){
                }
           }
     }
}
```

同步的解决方案：

* 信号量机制
    * 信号量是一个整型变量，可以对其进行down和up操作。
        * down：如果信号量大于0，进行-1操作；如果等于0，进入睡眠
        * up：对信号量执行+1操作，唤醒睡眠进程让其完成down操作
        * down和up需要被设计成原语，不可分割。
        如果信号量的取值只能是0,1，就成了互斥量（mutex）。0表示临界区加锁，1表示临界区解锁。
        ```C
        typedef int semaphore;semaphore mutex = 1;void P1() {
            down(&mutex);
            // 临界区
            up(&mutex);}

        void P2() {
            down(&mutex);
            // 临界区
            up(&mutex);}
        ```
        
    * 用信号量实现生产者消费者问题
        * 用一个互斥量mutex控制对缓冲区的互斥访问
        * 用两个信号量：empty和full记录空缓冲区和满缓冲区的数量
        * 注意：不能先down(mutex)再down(empty)（如果发现empty == 0，会死锁）
        
        ```C
        typedef int semaphore;semaphore mutex = 1;semaphore empty = N;semaphore full = 0;

        void producer() {
            while(TRUE) {
                int item = produce_item();
                down(&empty);
                down(&mutex);
                insert_item(item);
                up(&mutex);
                up(&full);
            }}

        void consumer() {
            while(TRUE) {
                down(&full);
                down(&mutex);
                int item = remove_item();
                up(&mutex);
                up(&empty);
            }}
        ```
    * 管程机制
        * 用信号量机制实现生产者消费者问题需要客户端代码做很多控制，管程可以把代码独立出来，不容易出错且使客户端代码调用更容易。
        * 管程的一个重要特性：在一个时刻只能有一个进程使用管程。进程无法继续执行时不能一直占用管程，否则其他进程永远不能使用管程。
        * 管程引入了**条件变量** 及相关操作：wait()和singal()来实现同步操作。wait导致进程阻塞，singal唤醒被阻塞的进程。

## 用户线程和内核线程的区别
用户线程不需要内核支持而在用户程序中实现，不依赖操作系统核心；内核线程由操作系统内核创建和撤销

* 内核支持线程是OS可感知的，用户级线程不是
* 用户级线程的创建撤销和调度不需要OS内核支持，内核需要
* 用户级线程执行系统调用指令将导致所属进程中断，内核支持线程只导致该线程中断
* 只有用户级线程的系统内CPU调度以进程为单位，有内核支持线程的系统内CPU调度以线程为单位
* 用户线程运行在一个中间系统上

## 用户态和核心态的区别

* 用户态和和心态是操作系统的两种运行级别，程序运行在3级特权级上时，可以称之为运行在用户态；运行在0级特权级上时，称之为运行在核心态。
* 主要差别：处于用户态时，进程能访问的内存空间和对象受到限制，所占有的处理机可被抢占；处于核心态的进程能访问所有的内存空间和对象，占有的处理机不可被抢占。

三种情况会导致用户态到内核态的切换：

* 系统调用
* 异常
* 外围设备的中断

这3种方式是系统在运行时由用户态转到内核态的最主要方式

## 用户栈和内核栈的区别

* 内核栈是内存中属于操作系统空间的一块区域，作用：1.保存中断现场；2.保存操作系统程序相互调用的参数
* 用户栈是用户进程空间里的一块区域，作用：保存用户空间子程序之间调用的参数

## 死锁的概念、导致死锁的原因

多个进程在运行过程中因为争夺资源陷入的一种僵局，如果没有外界干预，永远无法继续执行
产生原因：

1. 竞争资源；
2. 进程推进顺序非法

## 死锁的四个必要条件

* 互斥条件：进程排他性的使用分配到的资源
* 请求和保持条件：进程被阻塞时不释放申请到的资源
* 不可剥夺条件：进程已申请到的资源在使用完前不能被剥夺
* 环路等待条件：进程-资源的环形等待

## 处理死锁的四个方式

* 预防死锁：破坏死锁4个条件中的一个或多个
* 避免死锁：用安全的算法防止系统进入不安全状态（如银行家算法）
* 检测死锁：发生死锁后用一定的算法检测死锁，确定相关资源和进程，用一定的方法来清除
* 解除死锁：与检测结合，撤销进程或剥夺资源。

## 进程调度算法

* 先来先服务FCFS
* 短作业优先SJF：需要预知时间，对长作业不利，无法交互，完全不考虑紧迫程度
* 优先级调度PSA：外部赋予优先级，按优先级调度
* 高响应比算法HRN：结合了FCFS和SJF
* 时间片轮转调度RR：
* 多级反馈队列调度：目前公认较好：设置多个就绪队列并给予不同优先级，越高的队列时间片越短。
进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部…
只有当前一个队列为空的时候才会去调度下一个队列的进程

## 内存连续分配方式和采用几种算法及各自优劣

* 单一连续分配：适用于单道程序环境下
* 固定分区分配：多道程序系统
    * 划分分区的方法：分区大小相等、分区大小不相等
    * 内存分配：按分区大小排序并为之建立一张分区使用表
* 动态分区分配：根据进程实际需要动态地分配内存空间，主要操作是分配和回收

基于顺序搜索的动态分区分配算法：

* 首次适应（FF），倾向于优先利用低址区域
* 循环首次适应（NF），减少了查找开销，但会缺乏大分区
* 最佳适应（BF）：每次把满足要求的最小分区分配给作业，会产生很多小碎片
* 最坏适应（WF）：与最佳适应相反：碎片少，可能缺乏大分区

基于索引搜索的动态分区分配算法

* 快速适应（quick fit）：对相同大小的分区建立链表，用一张索引表管理不同大小的分区
* 伙伴系统：分区大小均为2^k，若找不到满足需要的最小分区，则对大一号的分区进行二分。如果还没有，再大一号……
* 哈希算法：构造一张以空闲分区大小为关键字的哈希表，分配时根据所需大小进行哈希计算

动态可重定位分区分配

* 紧凑：移动程序在内存中的位置，解决碎片问题
* 动态重定位：用新的起始地址置换原来的起始地址即可

## 动态链接和静态链接
程序的运行要经过的步骤：
1. 编译：编译形成若干目标模块
2. 链接：将编译结果和所需库函数链接成一个完整的装入模块
3. 装入：装入内存

程序的装入方式：

* 绝对装入方式：绝对地址，装入到内存中事先指定的位置，只适用于单道程序环境   
* 可重定位装入方式：将逻辑地址与起始地址相加得到绝对地址（重定位）
* 动态运行时的装入方式：将地址转换推迟到程序真正运行时再进行

程序的链接方式

* 静态链接：运行前链接成完整模块
* 装入时动态链接：装入内存时，边装入边链接。优点：1.便于修改和更新；2.便于实现对目标模块的共享（可将一个目标模块链接到多个应用模块上）
* 运行时动态链接：将某些模块推迟到程序执行时才进行

## 基本分页、请求分页存储管理方式
分页存储管理方式：将用户程序的地址空间划分为若干固定大小的区域，称为“页”，相应的将内存空间分为若干相同大小的块（2的幂）
需要一个页表来记录逻辑地址和实际存储地址之间的映射关系，以实现从页号到物理块号的映射。

由于页表也是存储在内存中的，因此和不用分页管理的存储方式相比，访问分页系统中内存数据需要两次的内存访问。
一次是从内存中访问页表，第二次就是根据第一次得到的物理地址访问内存取出数据。
快表（TLB）：CPU给出有效地址后，将页号送入高速缓存并与其中的所有页号比较，若匹配则直接读取并返回物理地址寄存器。若找不到，则需要访问内存。如果快表已满，则需要换出一些页表项。

两级页表或者多级页表的方法

## 基本分段、请求分段存储管理方式
分段存储管理方式：将用户程序地址空间分为若干大小不同的块，每段定义一个相对完整的信息。分配存储器时以段为单位

分段内存管理当中，地址是二维的，一维是段号，一维是段内地址。
每个段内部都是从0开始编址的。

## 分段分页方式的比较和各自的优缺点

* 页是物理单位，段是逻辑单位
* 页大小固定，段长度不固定
* 分页是系统行为，分段是用户行为

**段页式：先把用户程序分段，再把段分页**

## 几种页面置换算法，会算所需换页数

* 最佳置换算法：置换掉未来不会使用的或最久不用的页面
* 先进先出（FIFO）页面置换算法：总是淘汰最先进入内存的页面
* 最近最久未使用（LRU）：为每个页面赋予一个访问字段记录页面使用信息，淘汰最近最久未使用的页面
* 最近最少使用（LFU）：使用一个移位寄存器记录页面被访问的频率，在一个时间间隔内若被访问，则位移寄存器最高位置1。（由于速度太快，在一个时间间隔内，对某页访问1次和1000次是等效的）
* Clock置换算法：
    * 简单的：循环队列，被访问时置1，置换时若为1则置0，若为0则换它（最近未使用算法NRU）
    * 改进的：由于未被修改过的页不必写回，因此优先选择未被修改的页
        * 设置两个标记A（最近是否被访问）、M（是否被修改），优先换出AM=00，其次AM=01（遍历中将A置零），再次AM=00，最后AM=11
* 页面缓冲算法（PBA）：
    * 影响页面置换效率的因素：置换算法、写回磁盘的频率、读入内存的频率
    * PBA的特点：降低了页面置换频率，能够使用较简单的例如FIFO算法，实现简单。
    * PBA在内存中设置两个链表：
        * 空闲页面链表：用以分配给频繁缺页的进程装入页。换出的页在物理块中被挂在链表尾，这样再需要的时候就可以直接从链表中取。
        * 修改页面链表：↑

## 虚拟内存的定义及实现方式
虚拟存储器，是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而每位的成本却又接近于外存。

虚拟内存利用了程序的局部性原理

* 时间局部性
* 空间局部性

虚拟存储器的实现方式：
1. 请求分页存储管理
    * 硬件支持：页表机制，缺页中断机构，地址变换机构
    * 实现请求分页的软件
2. 请求分段存储管理
    * 硬件支持：段表机制，缺段中断机构，地址变换机构
    * 软件支持
3. 请求段页式存储管理


## 外存分配的几种方式

1. 连续：顺序访问容易、速度快，需要连续空间，产生碎片，需要事先知道文件长度，增删不方便，不适合动态文件
2. 链接：
    * 隐式连接
    * 显式链接（各物理块指针存在一张链表中），文件分配表FAT
        FAT技术（微软），引入“卷”。FAT12、FAT16、FAT32
        簇：一般是2n个盘块
    * NTFS：64位磁盘地址，支持长文件名，具有系统容错功能，保证数据一致性
        主控文件表MFT：NTFS卷结构的中心
3. 索引
    * 单级索引
    * 多级索引：文件太大，一个索引块装不下，建立一层索引表索引索引快。
    * 增量式索引：全面照顾不同大小的作业。小文件直接索引，中等文件使用单级索引，大文件用多级索引

## DMA（直接存储器访问方式）
> DMA是一种对IO设备的控制方式

以数据块为传输基本单位
数据从设备直接送入内存或相反
仅在传送开始和结束时需要CPU干预
![71a0059a540dd4bc8431bd45880aa606.png](/img/计算机基础/计算机操作系统-DMA.png)

## Spooling 假脱机
> 假脱机（Spooling） 将1台物理I/O设备虚拟为多台逻辑I/O设备

组成：

* 输入井和输出井
* 输入缓冲区和输出缓冲区
* 输入进程和输出进程
* 井管理程序

假脱机技术的特点：

* 提高了I/O速度
* 将独占设备改造为共享设备
* 实现了虚拟设备功能

缓冲区的作用

* 缓和CPU和I/O的速度不匹配
* 减少CPU中断频率，放宽CPU对中断响应时间的限制
* 解决数据粒度不匹配问题
* 提高CPU和I/O设备之间的并行性

![038d35d1257223c33b8833591ea95703.png](/img/计算机基础/计算机操作系统-Spooling.png)
![713c5889624fdb004559b901cc6c8beb.png](/img/计算机基础/计算机操作系统-Spooling缓冲区的工作方式.png)
![5395f6d092658271ed374b29cc926243.png](/img/计算机基础/计算机操作系统-Spooling工作原理.png)
